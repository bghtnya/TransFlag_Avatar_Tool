<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤´åƒé±¼æ¿è·¨æ——æ·»åŠ å·¥å…· ğŸ¥ğŸ³ï¸â€âš§ï¸</title>
    <style>
        body {
            font-family: 'Microsoft YaHei', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }

        .upload-section {
            margin-bottom: 30px;
            text-align: center;
            padding: 20px;
            border: 2px dashed #ccc;
            border-radius: 8px;
            transition: all 0.3s;
            background-color: #f9f9f9;
        }

        .upload-section.drag-over {
            background-color: #e8f5e9;
            border-color: #4CAF50;
        }

        #avatarUpload {
            display: none;
        }

        .upload-btn {
            display: inline-block;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
            margin-bottom: 10px;
        }

        .upload-btn:hover {
            background-color: #45a049;
        }

        #fileName {
            display: block;
            margin: 10px 0;
            font-size: 14px;
            color: #666;
        }

        .drag-tip {
            margin: 10px 0 0;
            color: #888;
            font-size: 14px;
        }

        .preview-container {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            margin-bottom: 30px;
            gap: 20px;
        }

        .preview-item {
            text-align: center;
            flex: 1;
            min-width: 250px;
            max-width: calc(50% - 10px);
        }

        .preview-item h3 {
            margin-bottom: 15px;
            font-size: 16px;
        }

        .example-row {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 30px;
        }

        .example-col {
            flex: 0 0 45%;
            min-width: 200px;
            max-width: 300px;
            text-align: center;
        }

        .canvas-wrapper {
            position: relative;
            width: 100%;
            max-width: 300px;
            margin: 0 auto 20px;
            background-color: #e9e9e9;
            border-radius: 8px;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.1);
        }

        canvas {
            display: block;
            width: 300px;
            height: 300px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            background-color: #f5f5f5;
            margin: 0 auto;
        }

        #downloadBtn {
            background-color: #4CAF50;
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1em;
            transition: background-color 0.3s;
            display: block;
            margin: 0 auto;
        }

        #downloadBtn:hover:not(:disabled) {
            background-color: #45a049;
        }

        .example-container {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }

        .example-avatar,
        .example-flag {
            width: 150px;
            height: 150px;
            margin: 10px auto;
            background-color: #f5f5f5;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .example-avatar img,
        .example-flag img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .flag-controls {
            margin-top: 15px;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .control-group {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
        }

        .control-group label {
            width: 60px;
            font-weight: bold;
        }

        .control-group input[type="range"] {
            flex: 1;
            margin: 0 10px;
        }

        #resetFlagBtn {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        #resetFlagBtn:hover {
            background-color: #45a049;
        }

        #imageCanvas {
            cursor: move;
        }

        .contributor-list {
            list-style: none;
            padding: 0;
            margin: 10px 0;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 20px;
        }

        .contributor-item {
            display: inline-flex;
            align-items: center;
            font-weight: bold;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            transition: background-color 0.3s;
        }

        .contributor-item:hover {
            background-color: #e0e0e0;
        }

        .contributor-avatar {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            margin-right: 8px;
            border: 2px solid #4CAF50;
            vertical-align: middle;
        }

        .contributor-login {
            color: #333;
            text-decoration: none;
            transition: color 0.3s;
        }

        .contributor-login:hover {
            color: #4CAF50;
            text-decoration: underline;
        }

        .tools-integration {
            margin-top: 30px;
            padding: 20px;
            border-top: 1px solid #eee;
            text-align: center;
        }

        .tools-integration h3 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.2em;
        }

        .tools-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .tool-btn {
            display: flex;
            align-items: center;
            padding: 15px 25px;
            background: linear-gradient(145deg, #ffffff, #f0f0f0);
            border: 1px solid #eee;
            border-radius: 12px;
            text-decoration: none;
            color: #333;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }

        .tool-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            border-color: #4CAF50;
        }

        .tool-icon {
            font-size: 24px;
            margin-right: 15px;
        }

        .tool-info {
            text-align: left;
        }

        .tool-info h4 {
            margin: 0;
            font-size: 16px;
            color: #333;
        }

        .tool-info p {
            margin: 5px 0 0;
            font-size: 14px;
            color: #666;
        }

        .main-footer {
            margin-top: 40px;
            padding: 20px 0;
            text-align: center;
            border-top: 1px solid #ddd;
            color: #666;
            font-size: 14px;
        }

        .main-footer p a {
            color: #4CAF50;
            text-decoration: none;
            font-weight: bold;
        }

        .main-footer p a:hover {
            text-decoration: underline;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>å¤´åƒé±¼æ¿è·¨æ——æ·»åŠ å·¥å…· ğŸ¥ğŸ³ï¸â€âš§ï¸</h1>

        <div class="upload-section" id="dropArea">
            <input type="file" id="avatarUpload" accept="image/*">
            <label for="avatarUpload" class="upload-btn">ä¸Šä¼ å¤´åƒ</label>
            <span id="fileName"></span>
            <p class="drag-tip">æˆ–å°†å›¾ç‰‡æ‹–æ”¾åˆ°æ­¤å¤„</p>
        </div>

        <div class="preview-container">
            <div class="preview-item">
                <h3>åŸå§‹å¤´åƒ</h3>
                <div class="canvas-wrapper">
                    <canvas id="originalCanvas"></canvas>
                </div>
            </div>
            <div class="preview-item">
                <h3>æ·»åŠ é±¼æ¿è·¨æ——æ•ˆæœ</h3>
                <div class="canvas-wrapper">
                    <canvas id="imageCanvas"></canvas>
                </div>

                <div class="flag-preview"></div>
            </div>
        </div>

        <button id="downloadBtn" disabled>ä¸‹è½½å¤„ç†åçš„å¤´åƒ</button>

        <div class="example-container">
            <h3>ç¤ºä¾‹å›¾ç‰‡</h3>
            <div class="example-row">
                <div class="example-col">
                    <p>æ‚¨çš„å¤´åƒ:</p>
                    <div class="example-avatar">
                        <img src="./res/å¤´åƒåŸå§‹.png" alt="ç¤ºä¾‹å¤´åƒ">
                    </div>
                </div>
                <div class="example-col">
                    <p>æ·»åŠ é±¼æ¿è·¨æ——æ•ˆæœ:</p>
                    <div class="example-flag">
                        <img src="./res/å¤´åƒå¤„ç†.png" alt="é±¼æ¿è·¨æ——æ•ˆæœ">
                    </div>
                </div>
            </div>
        </div>


        <div class="tools-integration">
            <h3>è¯•è¯•å…¶ä»–å·¥å…·</h3>
            <div class="tools-buttons">
                <a href="https://transflag.luoxue.cc/" class="tool-btn" target="_blank">
                    <span class="tool-icon">ğŸ³ï¸â€âš§ï¸</span>
                    <div class="tool-info">
                        <h4>å¤´åƒæ·»åŠ é±¼æ¿è·¨æ——å·¥å…·ğŸ³ï¸â€âš§ï¸ğŸ¥ï¼ˆåœ†å½¢æ”¯æŒæ¨ç‰¹ï¼‰</h4>
                        <p>by luoxue3943</p>
                    </div>
                </a>
            </div>
        </div>
    </div>

    <footer class="main-footer">
        <div id="contributorsContainer">
            <p>æ­£åœ¨åŠ è½½è´¡çŒ®è€…ä¿¡æ¯...</p>
        </div>
        <p>é¡¹ç›®ä»“åº“ï¼š<a href="https://github.com/bghtnya/TransFlag_Avatar_Tool/"
                target="_blank">TransFlag_Avatar_Tool</a></p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const avatarUpload = document.getElementById('avatarUpload');
            const imageCanvas = document.getElementById('imageCanvas');
            const originalCanvas = document.getElementById('originalCanvas');
            const downloadBtn = document.getElementById('downloadBtn');
            const dropArea = document.getElementById('dropArea');
            const fileName = document.getElementById('fileName');
            const ctx = imageCanvas.getContext('2d');
            const originalCtx = originalCanvas.getContext('2d');

            const FLAG_IMAGE_PATH = './res/å³ä¸‹é±¼æ¿è·¨æ——æ¨¡æ¿.png';
            const FLAG_SIZE_RATIO = 0.9;
            const CANVAS_SIZE = 300;
            imageCanvas.width = originalCanvas.width = CANVAS_SIZE;
            imageCanvas.height = originalCanvas.height = CANVAS_SIZE;

            const processCanvas = document.createElement('canvas');
            const processCtx = processCanvas.getContext('2d');

            let originalImage = null;
            let originalFileName = '';
            let flagOffset = { x: 0, y: 0 };
            let flagScale = 1.0;
            let flagRotation = 0;
            let flagStretch = { x: 1.0, y: 1.0 }; // æ–°ï¼šéç­‰æ¯”æ‹‰ä¼¸æ¯”ä¾‹

            let isDragging = false;
            let isTransforming = false;
            let activeControlPoint = null;
            let lastMouse = { x: 0, y: 0 };
            let dragStart = { x: 0, y: 0 };
            let startScale = 1.0;
            let startRotation = 0;
            let startStretch = { ...flagStretch };

            const CONTROL_POINT_RADIUS = 8;
            const ROTATION_HANDLE_LENGTH = 30;
            let controlPoints = {};
            let flagRect = {};

            // æ§ä»¶ UIï¼šåŠ¨æ€åˆ›å»ºå¹¶æ’å…¥åˆ° .flag-preview å®¹å™¨ä¸­
            const controls = document.createElement('div');
            controls.className = 'flag-controls';
            controls.innerHTML = `
        <div class="control-group">
            <label>ç¼©æ”¾ï¼š</label>
            <input type="range" id="flagScaleSlider" min="0.5" max="2" step="0.1" value="1">
            <input type="number" id="flagScaleInput" min="0.5" max="2" step="0.1" value="1.0" style="width:60px;margin-left:5px;">
        </div>
        <div class="control-group">
            <label>æ—‹è½¬ï¼š</label>
            <input type="range" id="flagRotationSlider" min="0" max="360" step="1" value="0">
            <input type="number" id="flagRotationInput" min="0" max="360" step="1" value="0" style="width:60px;margin-left:5px;">
        </div>
        <div class="control-group">
            <button id="resetFlagBtn">é‡ç½®</button>
        </div>
    `;
            const previewArea = document.querySelector('.flag-preview');
            if (previewArea) previewArea.appendChild(controls);

            const flagScaleSlider = document.getElementById('flagScaleSlider');
            const flagRotationSlider = document.getElementById('flagRotationSlider');
            const flagScaleInput = document.getElementById('flagScaleInput');
            const flagRotationInput = document.getElementById('flagRotationInput');
            const resetFlagBtn = document.getElementById('resetFlagBtn');

            const flagImg = new Image();
            flagImg.crossOrigin = "Anonymous";
            flagImg.src = FLAG_IMAGE_PATH;

            // åæ ‡æ¢ç®—
            function getPreviewTransform() {
                if (!originalImage) return { scale: 1, offsetX: 0, offsetY: 0 };
                const scale = Math.min(CANVAS_SIZE / originalImage.width, CANVAS_SIZE / originalImage.height);
                const offsetX = (CANVAS_SIZE - originalImage.width * scale) / 2;
                const offsetY = (CANVAS_SIZE - originalImage.height * scale) / 2;
                return { scale, offsetX, offsetY };
            }
            function previewToProcess(x, y) {
                const t = getPreviewTransform();
                return { x: (x - t.offsetX) / t.scale, y: (y - t.offsetY) / t.scale };
            }
            function processToPreview(x, y) {
                const t = getPreviewTransform();
                return { x: x * t.scale + t.offsetX, y: y * t.scale + t.offsetY };
            }

            // è½½å…¥å¤´åƒ
            function processImageFile(file) {
                if (!file) return;
                fileName.textContent = file.name;
                originalFileName = file.name.replace(/\.[^/.]+$/, "");
                const reader = new FileReader();
                reader.onload = e => {
                    const img = new Image();
                    img.onload = () => {
                        originalImage = img;
                        processCanvas.width = img.width;
                        processCanvas.height = img.height;
                        drawOriginal();
                        drawFlag();
                        downloadBtn.disabled = false;
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            function drawOriginal() {
                if (!originalImage) return;
                const s = Math.min(CANVAS_SIZE / originalImage.width, CANVAS_SIZE / originalImage.height);
                const w = originalImage.width * s, h = originalImage.height * s;
                const x = (CANVAS_SIZE - w) / 2, y = (CANVAS_SIZE - h) / 2;
                originalCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                originalCtx.drawImage(originalImage, x, y, w, h);
            }

            function drawFlag() {
                if (!originalImage) return;
                processCtx.clearRect(0, 0, processCanvas.width, processCanvas.height);
                processCtx.drawImage(originalImage, 0, 0);

                const base = Math.min(originalImage.width, originalImage.height);
                const flagBaseSize = base * FLAG_SIZE_RATIO;
                const flagWidth = flagBaseSize * flagScale * flagStretch.x;
                const flagHeight = (flagImg.height / flagImg.width) * flagBaseSize * flagScale * flagStretch.y;

                // é»˜è®¤ä½ç½®åœ¨å³ä¸‹è§’
                const defaultX = originalImage.width - flagWidth;
                const defaultY = originalImage.height - flagHeight;
                const x = defaultX + flagOffset.x;
                const y = defaultY + flagOffset.y;
                flagRect = { x, y, width: flagWidth, height: flagHeight };

                processCtx.save();
                // ç§»åŠ¨åˆ°æ——å¸œä¸­å¿ƒï¼Œæ—‹è½¬ï¼Œå†ç»˜åˆ¶
                processCtx.translate(x + flagWidth / 2, y + flagHeight / 2);
                processCtx.rotate(flagRotation * Math.PI / 180);
                processCtx.drawImage(flagImg, -flagWidth / 2, -flagHeight / 2, flagWidth, flagHeight);
                processCtx.restore();

                updatePreview();
                updateControlPoints();
            }

            function updatePreview() {
                const t = getPreviewTransform();
                ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                ctx.drawImage(processCanvas, 0, 0, processCanvas.width, processCanvas.height,
                    t.offsetX, t.offsetY, processCanvas.width * t.scale, processCanvas.height * t.scale);
            }

            // è®¡ç®—æ§åˆ¶ç‚¹ä½ç½®ï¼ˆPSé£æ ¼çš„å…³é”®ï¼‰
            function updateControlPoints() {
                const cX = flagRect.x + flagRect.width / 2;
                const cY = flagRect.y + flagRect.height / 2;
                const angle = flagRotation * Math.PI / 180;
                const rotatePoint = (x, y) => {
                    const dx = x - cX, dy = y - cY;
                    return {
                        x: cX + dx * Math.cos(angle) - dy * Math.sin(angle),
                        y: cY + dx * Math.sin(angle) + dy * Math.cos(angle)
                    };
                };
                const tl = rotatePoint(flagRect.x, flagRect.y);
                const tr = rotatePoint(flagRect.x + flagRect.width, flagRect.y);
                const bl = rotatePoint(flagRect.x, flagRect.y + flagRect.height);
                const br = rotatePoint(flagRect.x + flagRect.width, flagRect.y + flagRect.height);
                const tMid = rotatePoint(flagRect.x + flagRect.width / 2, flagRect.y);
                const handleLen = ROTATION_HANDLE_LENGTH / getPreviewTransform().scale;
                // æ—‹è½¬æ‰‹æŸ„ä½ç½®
                const rot = { x: tMid.x + handleLen * Math.sin(-angle), y: tMid.y - handleLen * Math.cos(-angle) };
                controlPoints = {
                    topLeft: processToPreview(tl.x, tl.y),
                    topRight: processToPreview(tr.x, tr.y),
                    bottomLeft: processToPreview(bl.x, bl.y),
                    bottomRight: processToPreview(br.x, br.y),
                    rotation: processToPreview(rot.x, rot.y)
                };
                drawControlPoints();
            }

            // ç»˜åˆ¶æ§åˆ¶ç‚¹å’Œå˜æ¢æ¡†
            function drawControlPoints() {
                updatePreview();
                ctx.strokeStyle = '#00AAFF';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(controlPoints.topLeft.x, controlPoints.topLeft.y);
                ctx.lineTo(controlPoints.topRight.x, controlPoints.topRight.y);
                ctx.lineTo(controlPoints.bottomRight.x, controlPoints.bottomRight.y);
                ctx.lineTo(controlPoints.bottomLeft.x, controlPoints.bottomLeft.y);
                ctx.closePath();
                ctx.stroke();

                const tmx = (controlPoints.topLeft.x + controlPoints.topRight.x) / 2;
                const tmy = (controlPoints.topLeft.y + controlPoints.topRight.y) / 2;
                ctx.beginPath();
                ctx.moveTo(tmx, tmy);
                ctx.lineTo(controlPoints.rotation.x, controlPoints.rotation.y);
                ctx.stroke();

                const drawPt = (x, y, active, txt) => {
                    ctx.fillStyle = active ? '#FF4400' : '#00AAFF';
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, CONTROL_POINT_RADIUS, 0, Math.PI * 2);
                    ctx.fill(); ctx.stroke();
                    ctx.font = 'bold 12px Arial';
                    ctx.fillStyle = '#fff';
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 3;
                    ctx.strokeText(txt, x + 12, y + 4);
                    ctx.fillText(txt, x + 12, y + 4);
                };
                for (const p of ['topLeft', 'topRight', 'bottomLeft', 'bottomRight'])
                    drawPt(controlPoints[p].x, controlPoints[p].y, activeControlPoint === p, 'å˜å½¢');
                drawPt(controlPoints.rotation.x, controlPoints.rotation.y, activeControlPoint === 'rotation', 'æ—‹è½¬');
            }

            // æ§ä»¶è”åŠ¨ï¼ˆè¿æ¥æ»‘å—/è¾“å…¥æ¡†å’Œæ——å¸œå˜é‡ï¼‰
            function syncScale(val) {
                flagScale = Math.min(2, Math.max(0.5, parseFloat(val)));
                flagScaleSlider.value = flagScale;
                flagScaleInput.value = flagScale.toFixed(1);
                drawFlag();
            }
            function syncRotation(val) {
                flagRotation = (parseFloat(val) % 360 + 360) % 360;
                flagRotationSlider.value = flagRotation;
                flagRotationInput.value = flagRotation.toFixed(0);
                drawFlag();
            }
            flagScaleSlider.oninput = e => syncScale(e.target.value);
            flagScaleInput.onchange = e => syncScale(e.target.value);
            flagRotationSlider.oninput = e => syncRotation(e.target.value);
            flagRotationInput.onchange = e => syncRotation(e.target.value);
            resetFlagBtn.onclick = () => {
                flagOffset = { x: 0, y: 0 };
                flagScale = 1.0; flagRotation = 0; flagStretch = { x: 1, y: 1 };
                syncScale(1); syncRotation(0);
            };

            // é¼ æ ‡äº¤äº’ï¼šå®ç° PS é£æ ¼çš„æ‹–åŠ¨/å˜å½¢
            imageCanvas.addEventListener('mousedown', e => {
                if (!originalImage) return;
                const rect = imageCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left, y = e.clientY - rect.top;
                activeControlPoint = null;
                // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†æ§åˆ¶ç‚¹
                for (const k in controlPoints) {
                    const dx = x - controlPoints[k].x, dy = y - controlPoints[k].y;
                    if (Math.sqrt(dx * dx + dy * dy) < CONTROL_POINT_RADIUS * 2) {
                        activeControlPoint = k;
                        isTransforming = true;
                        dragStart = { x, y };
                        startScale = flagScale;
                        startRotation = flagRotation;
                        startStretch = { ...flagStretch };
                        return;
                    }
                }
                // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†æ——å¸œåŒºåŸŸï¼ˆç”¨äºç§»åŠ¨ï¼‰
                const p = previewToProcess(x, y);
                const cx = flagRect.x + flagRect.width / 2, cy = flagRect.y + flagRect.height / 2;
                const ang = -flagRotation * Math.PI / 180;
                const dx = p.x - cx, dy = p.y - cy;
                // åå‘æ—‹è½¬åæ ‡ç‚¹ä»¥æ£€æŸ¥æ˜¯å¦åœ¨æ—‹è½¬å‰çš„çŸ©å½¢å†…
                const rx = cx + dx * Math.cos(ang) - dy * Math.sin(ang);
                const ry = cy + dx * Math.sin(ang) + dy * Math.cos(ang);
                if (rx >= flagRect.x && rx <= flagRect.x + flagRect.width && ry >= flagRect.y && ry <= flagRect.y + flagRect.height) {
                    isDragging = true;
                    lastMouse = { x, y };
                }
            });

            imageCanvas.addEventListener('mousemove', e => {
                if (!originalImage) return;
                const rect = imageCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left, y = e.clientY - rect.top;
                if (isTransforming && activeControlPoint) {
                    const c = previewToProcess(x, y);
                    const s = previewToProcess(dragStart.x, dragStart.y);
                    const cx = flagRect.x + flagRect.width / 2, cy = flagRect.y + flagRect.height / 2;
                    const startDistX = s.x - cx, startDistY = s.y - cy;
                    const nowDistX = c.x - cx, nowDistY = c.y - cy;
                    const ratioX = nowDistX / startDistX || 1;
                    const ratioY = nowDistY / startDistY || 1;
                    if (activeControlPoint === 'rotation') {
                        // æ—‹è½¬é€»è¾‘
                        const startA = Math.atan2(s.y - cy, s.x - cx);
                        const nowA = Math.atan2(c.y - cy, c.x - cx);
                        // æ›´æ–°æ—‹è½¬è§’åº¦ï¼Œå¹¶åŒæ­¥æ»‘å—
                        syncRotation(startRotation + (nowA - startA) * 180 / Math.PI);
                    } else {
                        // ç¼©æ”¾/éç­‰æ¯”å˜å½¢é€»è¾‘
                        if (e.shiftKey) {
                            // æŒ‰ä½ Shift é”®è¿›è¡Œç­‰æ¯”ç¼©æ”¾
                            syncScale(startScale * Math.max(ratioX, ratioY));
                        } else {
                            // éç­‰æ¯”æ‹‰ä¼¸
                            flagStretch.x = Math.min(2, Math.max(0.5, startStretch.x * ratioX));
                            flagStretch.y = Math.min(2, Math.max(0.5, startStretch.y * ratioY));
                            drawFlag();
                        }
                    }
                } else if (isDragging) {
                    // æ‹–åŠ¨é€»è¾‘
                    const deltaX = x - lastMouse.x;
                    const deltaY = y - lastMouse.y;
                    const t = getPreviewTransform();
                    flagOffset.x += deltaX / t.scale;
                    flagOffset.y += deltaY / t.scale;
                    lastMouse = { x, y };
                    drawFlag();
                }
            });
            window.addEventListener('mouseup', () => { isDragging = false; isTransforming = false; activeControlPoint = null; });
            imageCanvas.addEventListener('mouseleave', () => { isDragging = false; isTransforming = false; activeControlPoint = null; });

            avatarUpload.addEventListener('change', e => processImageFile(e.target.files[0]));
            if (dropArea) {
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(ev => dropArea.addEventListener(ev, e => { e.preventDefault(); e.stopPropagation(); }));
                ['dragenter', 'dragover'].forEach(ev => dropArea.addEventListener(ev, () => dropArea.classList.add('drag-over')));
                ['dragleave', 'drop'].forEach(ev => dropArea.addEventListener(ev, () => dropArea.classList.remove('drag-over')));
                dropArea.addEventListener('drop', e => processImageFile(e.dataTransfer.files[0]));
            }

            downloadBtn.addEventListener('click', () => {
                if (!originalImage) return;
                const dataURL = processCanvas.toDataURL('image/png');
                const a = document.createElement('a');
                a.href = dataURL;
                a.download = (originalFileName || 'avatar') + '_with_flag.png';
                a.click();
            });

            // --- åŠ¨æ€è·å–è´¡çŒ®è€…ä¿¡æ¯ ---
            function fetchContributors() {
                const repo = 'bghtnya/TransFlag_Avatar_Tool';
                const url = `https://api.github.com/repos/${repo}/contributors`;
                const container = document.getElementById('contributorsContainer');

                fetch(url)
                    .then(response => {
                        if (!response.ok) {
                            // å¦‚æœ API è°ƒç”¨å¤±è´¥ï¼ˆä¾‹å¦‚è¾¾åˆ°é€Ÿç‡é™åˆ¶ï¼‰ï¼Œè¿”å›é”™è¯¯
                            throw new Error(`GitHub API error: ${response.statusText}`);
                        }
                        return response.json();
                    })
                    .then(contributors => {
                        // è¿‡æ»¤æ‰ GitHub Actions æˆ–å…¶ä»–è‡ªåŠ¨åŒ–æœºå™¨äºº
                        const humanContributors = contributors.filter(c => c.type === 'User');

                        if (humanContributors.length === 0) {
                            container.innerHTML = '<p>æš‚æ— è´¡çŒ®è€…ä¿¡æ¯ã€‚</p>';
                            return;
                        }

                        const listItems = humanContributors.map(contributor => `
                    <li class="contributor-item">
                        <img src="${contributor.avatar_url}" alt="${contributor.login}'s avatar" class="contributor-avatar">
                        <a href="${contributor.html_url}" target="_blank" class="contributor-login">${contributor.login}</a>
                    </li>
                `).join('');

                        container.innerHTML = `
                    <p>é¡¹ç›®è´¡çŒ®è€…ï¼š</p>
                    <ul class="contributor-list">
                        ${listItems}
                    </ul>
                `;
                    })
                    .catch(error => {
                        console.error("Failed to fetch contributors:", error);
                        container.innerHTML = '<p>æ— æ³•åŒæ­¥è´¡çŒ®è€…ä¿¡æ¯ã€‚è¯·è®¿é—®é¡¹ç›®ä»“åº“æŸ¥çœ‹ã€‚</p>';
                    });
            }

            // åœ¨é¡µé¢åŠ è½½å®Œæ¯•åç«‹å³è°ƒç”¨
            fetchContributors();
        });
    </script>
</body>

</html>