<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤´åƒé±¼æ¿è·¨æ——æ·»åŠ å·¥å…· ğŸ¥ğŸ³ï¸â€âš§ï¸</title>
    <style>
        body {
            font-family: 'Microsoft YaHei', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.15);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }

        /* --- ä¸Šä¼ åŒºåŸŸ --- */
        .upload-section {
            margin-bottom: 30px;
            text-align: center;
            padding: 25px;
            border: 3px dashed #a0a0a0;
            border-radius: 12px;
            transition: all 0.3s;
            background-color: #f9f9f9;
        }

        .upload-section.drag-over {
            border-color: #007bff;
            background-color: #e6f7ff;
        }

        #avatarUpload {
            display: none;
        }

        .upload-btn {
            display: inline-block;
            padding: 12px 25px;
            background-color: #4CAF50;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .upload-btn:hover {
            background-color: #45a049;
            transform: translateY(-1px);
        }

        .drag-tip {
            color: #666;
            margin-top: 5px;
        }

        /* ---------------------------------------- */
        /* âœ¨ æ——å¸œé€‰æ‹©åŒºåŸŸ (å›¾ç‰‡ç”»å»Šæ ·å¼) âœ¨ */
        .flag-selection-area {
            margin-bottom: 30px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #f9f9f9;
            text-align: center;
        }

        .flag-gallery {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-top: 15px;
        }

        .flag-item {
            cursor: pointer;
            border: 3px solid transparent;
            border-radius: 6px;
            overflow: hidden;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
            background-color: white;
            text-align: center;
            padding: 5px;
            flex: 0 0 auto;
            /* ä¸æ”¾å¤§ä¸ç¼©å° */
            width: 130px;
            /* å‡å°å®½åº¦ä»¥å®¹çº³æ›´å¤š */
        }

        .flag-item.selected {
            border-color: #007bff;
            box-shadow: 0 0 10px rgba(0, 123, 255, 0.8);
            background-color: #e6f7ff;
        }

        .flag-item:hover:not(.selected) {
            border-color: #a0a0a0;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .flag-preview-img {
            width: 120px;
            /* è°ƒæ•´ï¼šé¢„è§ˆç¼©å° */
            height: 60px;
            /* è°ƒæ•´ï¼šä¿æŒå¤§è‡´ 2:1 æ¯”ä¾‹ */
            object-fit: contain;
            display: block;
            margin: 0 auto;
        }

        .flag-name {
            font-size: 13px;
            margin-top: 5px;
            color: #555;
            word-break: keep-all;
        }

        /* ---------------------------------------- */

        /* é¢„è§ˆåŒºåŸŸå¸ƒå±€æ›´æ–°ï¼šä¸‰åˆ—ï¼Œä¸”ç•¥å¾®ç¼©å° */
        .preview-container {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            margin-bottom: 30px;
            gap: 20px;
        }

        .preview-item {
            text-align: center;
            flex: 1 1 30%;
            min-width: 250px;
            max-width: 300px;
            padding: 10px;
        }

        /* âœ¨ å ä½ç¬¦å’Œ Canvas å®¹å™¨æ ·å¼ âœ¨ */
        .canvas-wrapper {
            width: 300px;
            height: 300px;
            margin: 0 auto;
            border: 2px solid #ddd;
            border-radius: 10px;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #eee;
            position: relative;
            /* ç¡®ä¿ canvas å®¹å™¨æ˜¯å®šä½å‚è€ƒç‚¹ */
        }

        .canvas-wrapper:not([data-has-image="true"]) {
            border: 4px dashed #a0a0a0;
            background-color: #e0e0e0;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
        }

        /* åœ†å½¢é¢„è§ˆçš„ç‰¹æ®Šå®¹å™¨ */
        #circularWrapper {
            border-radius: 50%;
        }

        #circularCanvas {
            /* æ³¨æ„ï¼šåœ†å½¢è£å‰ªåœ¨ JS ä¸­å®ç°ï¼Œè¿™é‡Œåªè®¾ç½®å®¹å™¨åœ†è§’ */
            border-radius: 50%;
            border: 2px solid #007bff;
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.2);
        }

        /* è®©å¯äº¤äº’çš„ Canvas å…·æœ‰å¯ç‚¹å‡»å…‰æ ‡ */
        #imageCanvas,
        #circularCanvas {
            cursor: pointer;
        }

        .flag-preview {
            margin-top: 20px;
        }

        /* âœ¨ æ§åˆ¶å°ç¾åŒ– âœ¨ */
        .flag-controls {
            padding: 15px;
            border: 1px solid #ccc;
            border-radius: 8px;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 5px 0;
        }

        .control-group label {
            font-weight: bold;
            color: #555;
            min-width: 50px;
        }

        .control-group input[type="range"] {
            flex-grow: 1;
            margin: 0 10px;
        }

        .control-group input[type="number"] {
            width: 70px !important;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
            text-align: center;
        }

        .control-group button {
            padding: 8px 15px;
            background-color: #ff9800;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .control-group button:hover {
            background-color: #e68900;
        }

        /* ä¸‹è½½æŒ‰é’®æ ·å¼ (ä¿æŒä¸å˜) */
        #downloadBtn {
            background-color: #007bff;
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1.2em;
            font-weight: bold;
            transition: all 0.3s ease;
            display: block;
            margin: 30px auto;
            box-shadow: 0 4px 10px rgba(0, 123, 255, 0.3);
            opacity: 1;
        }

        #downloadBtn:hover:not(:disabled) {
            background-color: #0056b3;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 123, 255, 0.4);
        }

        #downloadBtn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        /* --- åº•éƒ¨å’Œè´¡çŒ®è€…ä¿¡æ¯ä¼˜åŒ– (é‡‡çº³ç”¨æˆ·å»ºè®®) --- */

        /* ä¸»é¡µè„šæ ·å¼ï¼Œç¡®ä¿å±…ä¸­å’Œä¸é¡µé¢ä¸»ä½“åˆ†éš” */
        .main-footer {
            margin-top: 40px;
            padding: 20px 0;
            text-align: center;
            border-top: 1px solid #ddd;
            /* æ·»åŠ é¡¶éƒ¨è¾¹æ¡†åˆ†éš” */
            color: #666;
            /* ç»Ÿä¸€é¢œè‰² */
            font-size: 14px;
        }

        /* è´¡çŒ®è€…å®¹å™¨æ ·å¼ */
        #contributorsContainer {
            margin-bottom: 15px;
        }

        /* ä¿®æ”¹ï¼šè´¡çŒ®è€…åˆ—è¡¨æ ·å¼ï¼Œä¿æŒå±…ä¸­å¯¹é½ */
        .contributor-list {
            list-style: none;
            padding: 0;
            margin: 10px 0;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 20px;
            /* å¢åŠ é—´éš” */
        }

        /* è´¡çŒ®è€…é¡¹ç›®æ ·å¼ */
        .contributor-item {
            display: inline-flex;
            align-items: center;
            font-weight: bold;
            padding: 5px 10px;
            /* å¢åŠ ç‚¹å‡»åŒºåŸŸå’Œè§†è§‰åˆ†éš” */
            border-radius: 15px;
            background-color: #f0f0f0;
            transition: background-color 0.3s;
        }

        .contributor-item:hover {
            background-color: #e0e0e0;
        }

        /* è´¡çŒ®è€…å¤´åƒæ ·å¼ */
        .contributor-avatar {
            width: 28px;
            /* ç•¥å¾®å¢å¤§ */
            height: 28px;
            /* ç•¥å¾®å¢å¤§ */
            border-radius: 50%;
            margin-right: 8px;
            /* å¢å¤§å³ä¾§é—´è· */
            border: 2px solid #4CAF50;
            /* æ·»åŠ å“ç‰Œè‰²è¾¹æ¡† */
            vertical-align: middle;
        }

        /* è´¡çŒ®è€…é“¾æ¥æ ·å¼ */
        .contributor-login {
            color: #333;
            /* é“¾æ¥é¢œè‰²æ”¹ä¸ºæ·±è‰²ï¼Œæ›´æ˜“è¯» */
            text-decoration: none;
            transition: color 0.3s;
        }

        .contributor-login:hover {
            color: #4CAF50;
            /* é¼ æ ‡æ‚¬åœæ—¶æ˜¾ç¤ºå“ç‰Œè‰² */
            text-decoration: underline;
        }

        /* é¡¹ç›®ä»“åº“é“¾æ¥æ ·å¼ */
        .main-footer p a {
            color: #4CAF50;
            text-decoration: none;
            font-weight: bold;
        }

        .main-footer p a:hover {
            text-decoration: underline;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>å¤´åƒé±¼æ¿è·¨æ——æ·»åŠ å·¥å…· ğŸ¥ğŸ³ï¸â€âš§ï¸</h1>

        <div class="upload-section" id="dropArea">
            <input type="file" id="avatarUpload" accept="image/*">
            <label for="avatarUpload" class="upload-btn">ä¸Šä¼ å¤´åƒ</label>
            <span id="fileName"></span>
            <p class="drag-tip">æˆ–å°†å›¾ç‰‡æ‹–æ”¾åˆ°æ­¤å¤„</p>
        </div>

        <div class="flag-selection-area">
            <h2>é€‰æ‹©æ——å¸œæ¨¡æ¿ï¼ˆç‚¹å‡»å›¾ç‰‡é€‰æ‹©ï¼‰</h2>
            <div id="flagGallery" class="flag-gallery">
            </div>
        </div>
        <div class="preview-container">
            <div class="preview-item">
                <h3>åŸå§‹å¤´åƒ</h3>
                <div class="canvas-wrapper" id="originalWrapper">
                    <canvas id="originalCanvas"></canvas>
                </div>
                <div class="flag-controls-info">
                    <p style="font-size: 14px; color: #555;">ç‚¹å‡»å³ä¾§é¢„è§ˆåŒºè¿›è¡Œæ——å¸œçš„ç¼–è¾‘</p>
                </div>
            </div>

            <div class="preview-item">
                <h3>é¢„è§ˆå¤„ç†å¤´åƒ-æ–¹</h3>
                <div class="canvas-wrapper" id="imageWrapper">
                    <canvas id="imageCanvas"></canvas>
                </div>
                <div class="flag-preview"></div>
            </div>

            <div class="preview-item">
                <h3>é¢„è§ˆå¤„ç†å¤´åƒ-åœ†</h3>
                <div class="canvas-wrapper" id="circularWrapper" style="border-radius: 50%;">
                    <canvas id="circularCanvas"></canvas>
                </div>
            </div>
        </div>

        <button id="downloadBtn" disabled>ä¸‹è½½å¤„ç†åçš„å¤´åƒ</button>


        <footer class="main-footer">
            <div id="contributorsContainer">
            </div>
            <p>é¡¹ç›®ä»“åº“ï¼š<a href="https://github.com/bghtnya/TransFlag_Avatar_Tool/"
                    target="_blank">TransFlag_Avatar_Tool</a>
            </p>
        </footer>

        <script>
            document.addEventListener('DOMContentLoaded', () => {
                // --- æ——å¸œé…ç½®è¡¨ ---
                const FLAG_TEMPLATES_ARRAY = [
                    { key: 'bottom_trans', name: 'åº•éƒ¨é±¼æ¿è·¨æ——', path: './res/åº•éƒ¨é±¼æ¿è·¨æ——æ¨¡æ¿.png', defaultScale: 1.2 },
                    { key: 'bottom_transles', name: 'åº•éƒ¨è·¨ Les é±¼æ¿', path: './res/åº•éƒ¨translesé±¼æ¿.png', defaultScale: 1.2 },
                    { key: 'bottom_les', name: 'åº•éƒ¨ Les é±¼æ¿', path: './res/åº•éƒ¨lesé±¼æ¿.png', defaultScale: 1.2 },
                    { key: 'right_bottom_trans', name: 'å³ä¸‹é±¼æ¿è·¨æ——', path: './res/å³ä¸‹é±¼æ¿è·¨æ——æ¨¡æ¿.png' },
                    { key: 'right_bottom_les', name: 'å³ä¸‹ Les é±¼æ¿', path: './res/å³ä¸‹lesé±¼æ¿.png' },
                    { key: 'right_bottom_transles', name: 'å³ä¸‹è·¨ Les é±¼æ¿', path: './res/å³ä¸‹translesé±¼æ¿.png' },
                ];

                const FLAG_TEMPLATES = FLAG_TEMPLATES_ARRAY.reduce((acc, template) => {
                    acc[template.key] = template;
                    return acc;
                }, {});

                let currentFlagKey = FLAG_TEMPLATES_ARRAY[0] ? FLAG_TEMPLATES_ARRAY[0].key : null;


                const avatarUpload = document.getElementById('avatarUpload');
                const originalCanvas = document.getElementById('originalCanvas');
                const imageCanvas = document.getElementById('imageCanvas');
                const circularCanvas = document.getElementById('circularCanvas');

                const originalWrapper = document.getElementById('originalWrapper');
                const imageWrapper = document.getElementById('imageWrapper');
                const circularWrapper = document.getElementById('circularWrapper');

                const downloadBtn = document.getElementById('downloadBtn');
                const dropArea = document.getElementById('dropArea');
                const fileName = document.getElementById('fileName');
                const flagGallery = document.getElementById('flagGallery');

                const originalCtx = originalCanvas.getContext('2d'); // ç”¨äºäº¤äº’å’Œæ§åˆ¶ç‚¹ç»˜åˆ¶
                const imageCtx = imageCanvas.getContext('2d'); // ç”¨äºæœ€ç»ˆæ–¹å½¢é¢„è§ˆ
                const circularCtx = circularCanvas.getContext('2d'); // ç”¨äºæœ€ç»ˆåœ†å½¢é¢„è§ˆ

                const FLAG_SIZE_RATIO = 0.9;
                const CANVAS_SIZE = 300;
                imageCanvas.width = originalCanvas.width = circularCanvas.width = CANVAS_SIZE;
                imageCanvas.height = originalCanvas.height = circularCanvas.height = CANVAS_SIZE;

                // ç¦»å± Canvasï¼Œç”¨äºè®¡ç®—å’Œç”Ÿæˆæœ€ç»ˆç»“æœ (åŸå§‹åˆ†è¾¨ç‡)
                const processCanvas = document.createElement('canvas');
                const processCtx = processCanvas.getContext('2d');

                let originalImage = null;
                let originalFileName = '';
                let flagOffset = { x: 0, y: 0 };
                let flagScale = 1.0;
                let flagRotation = 0;
                let flagStretch = { x: 1.0, y: 1.0 }; // æš‚æ—¶ä¸ç”¨ï¼Œä½†ä¿ç•™

                // --- çŠ¶æ€ç®¡ç† (ç”¨äºæ’¤é”€/é‡åšå’Œæ‹–åŠ¨ç»“æŸä¿å­˜) ---
                let historyStack = [];
                let historyIndex = -1;
                const MAX_HISTORY = 20;
                let saveTimeout = null; // ç”¨äºé™åˆ¶é¢‘ç¹ä¿å­˜çŠ¶æ€

                function saveState(initialLoad = false) {
                    const state = {
                        flagOffset: { ...flagOffset },
                        flagScale: flagScale,
                        flagRotation: flagRotation,
                        currentFlagKey: currentFlagKey,
                    };

                    // æ¸…ç†ç´¢å¼•ä¹‹åçš„çŠ¶æ€ (é‡åšçŠ¶æ€)
                    if (historyIndex < historyStack.length - 1) {
                        historyStack = historyStack.slice(0, historyIndex + 1);
                    }

                    // é™åˆ¶å†å²è®°å½•å¤§å°
                    if (historyStack.length >= MAX_HISTORY) {
                        historyStack.shift(); // ç§»é™¤æœ€æ—§çš„
                        historyIndex--;
                    }

                    // æ£€æŸ¥æ˜¯å¦ä¸æœ€åä¸€ä¸ªçŠ¶æ€ç›¸åŒï¼Œå¦‚æœæ˜¯åˆ™ä¸ä¿å­˜ (é¿å…é¢‘ç¹è®°å½•)
                    if (!initialLoad && historyStack.length > 0) {
                        const lastState = historyStack[historyStack.length - 1];
                        if (Math.abs(lastState.flagScale - state.flagScale) < 0.01 &&
                            Math.abs(lastState.flagRotation - state.flagRotation) < 1 &&
                            Math.abs(lastState.flagOffset.x - state.flagOffset.x) < 1 &&
                            Math.abs(lastState.flagOffset.y - state.flagOffset.y) < 1) {
                            return;
                        }
                    }

                    historyStack.push(state);
                    historyIndex = historyStack.length - 1;
                    // console.log(`Saved state: ${historyIndex}/${historyStack.length - 1}`);
                }

                // å»¶è¿Ÿä¿å­˜çŠ¶æ€ï¼Œç”¨äºæ‹–åŠ¨/æ»‘å—æ“ä½œ
                function deferredSaveState() {
                    clearTimeout(saveTimeout);
                    saveTimeout = setTimeout(saveState, 300); // 300ms åä¿å­˜
                }
                // --- çŠ¶æ€ç®¡ç†ç»“æŸ ---

                // --- æ‹–åŠ¨/å˜å½¢ç›¸å…³çš„å˜é‡å’Œé€»è¾‘ ---
                let isDragging = false;
                let isTransforming = false;
                let activeControlPoint = null; // 'center' for drag, 'scale' for scale/rotate
                let lastMouse = { x: 0, y: 0 };
                let dragStart = { x: 0, y: 0 };
                let startScale = 1.0;
                let startRotation = 0;

                const CONTROL_POINT_RADIUS = 8;
                const ROTATION_HANDLE_LENGTH = 30;
                let flagRect = {}; // å­˜å‚¨æ——å¸œåœ¨ processCanvas åæ ‡ç³»ä¸­çš„ä¿¡æ¯
                let controlPoints = {}; // å­˜å‚¨æ§åˆ¶ç‚¹åœ¨ originalCanvas åæ ‡ç³»ä¸­çš„ä¿¡æ¯ (æ³¨æ„ï¼šäº¤äº’æ—¶éœ€è¦è½¬æ¢åˆ°å½“å‰ Canvas åæ ‡)

                const flagImg = new Image();
                flagImg.crossOrigin = "Anonymous";

                // æ§ä»¶ UIï¼šåŠ¨æ€åˆ›å»ºå¹¶æ’å…¥åˆ° .flag-preview å®¹å™¨ä¸­ (ä¿æŒä¸å˜)
                const controls = document.createElement('div');
                controls.className = 'flag-controls';
                controls.innerHTML = `
					<div class="control-group">
						<label>ç¼©æ”¾ï¼š</label>
						<input type="range" id="flagScaleSlider" min="0.5" max="3.0" step="0.1" value="1.0">
						<input type="number" id="flagScaleInput" min="0.5" max="3.0" step="0.1" value="1.0">
					</div>
					<div class="control-group">
						<label>æ—‹è½¬ï¼š</label>
						<input type="range" id="flagRotationSlider" min="0" max="360" step="1" value="0">
						<input type="number" id="flagRotationInput" min="0" max="360" step="1" value="0">
					</div>
					<div class="control-group" style="justify-content: center; margin-top: 10px;">
						<button id="resetFlagBtn">é‡ç½®ä½ç½®/ç¼©æ”¾/æ—‹è½¬</button>
					</div>
				`;
                const previewArea = document.querySelector('.flag-preview');
                if (previewArea) previewArea.appendChild(controls);

                const flagScaleSlider = document.getElementById('flagScaleSlider');
                const flagRotationSlider = document.getElementById('flagRotationSlider');
                const flagScaleInput = document.getElementById('flagScaleInput');
                const flagRotationInput = document.getElementById('flagRotationInput');
                const resetFlagBtn = document.getElementById('resetFlagBtn');

                // --- åŒæ­¥å‡½æ•° ---
                function syncScale(scale, isInput = true) {
                    flagScale = parseFloat(scale);
                    if (isNaN(flagScale)) return;
                    flagScale = Math.max(0.5, Math.min(3.0, flagScale)); // é€‚å½“æ”¾å®½ç¼©æ”¾èŒƒå›´
                    flagScale = Math.round(flagScale * 100) / 100; // é™åˆ¶ä¸¤ä½å°æ•°

                    if (isInput) {
                        flagScaleSlider.value = flagScale;
                        flagScaleInput.value = flagScale.toFixed(2);
                    }
                }

                function syncRotation(rotation, isInput = true) {
                    flagRotation = parseInt(rotation);
                    if (isNaN(flagRotation)) return;
                    flagRotation = flagRotation % 360; // é™åˆ¶ 0-360 åº¦
                    if (flagRotation < 0) flagRotation += 360;

                    if (isInput) {
                        flagRotationSlider.value = flagRotation;
                        flagRotationInput.value = flagRotation;
                    }
                }
                // --- åŒæ­¥å‡½æ•°ç»“æŸ ---

                // --- æ§ä»¶äº‹ä»¶ç›‘å¬å™¨ (ä¿æŒä¸å˜) ---
                flagScaleSlider.addEventListener('input', () => {
                    syncScale(flagScaleSlider.value, true);
                    drawFlag();
                    deferredSaveState();
                });

                flagScaleInput.addEventListener('input', () => {
                    syncScale(flagScaleInput.value, true);
                    drawFlag();
                    deferredSaveState();
                });

                flagRotationSlider.addEventListener('input', () => {
                    syncRotation(flagRotationSlider.value, true);
                    drawFlag();
                    deferredSaveState();
                });

                flagRotationInput.addEventListener('input', () => {
                    syncRotation(flagRotationInput.value, true);
                    drawFlag();
                    deferredSaveState();
                });

                flagRotationInput.addEventListener('keydown', (e) => {
                    if (!originalImage || e.target !== flagRotationInput) return;

                    if ((e.ctrlKey || e.metaKey || e.shiftKey) && (e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
                        e.preventDefault();
                        const step = 45;
                        let newValue = parseInt(flagRotationInput.value) || 0;

                        if (e.key === 'ArrowUp') {
                            newValue += step;
                        } else {
                            newValue -= step;
                        }
                        syncRotation(newValue, true);
                        drawFlag();
                        saveState();
                    }
                });

                resetFlagBtn.addEventListener('click', () => {
                    const currentTemplate = FLAG_TEMPLATES[currentFlagKey];
                    resetFlagTransform(currentTemplate.defaultScale || 1.0);
                });
                // --- æ§ä»¶äº‹ä»¶ç›‘å¬å™¨ç»“æŸ ---


                // --- æ——å¸œå›¾ç‰‡ç”»å»Šæ¸²æŸ“å’Œé€‰æ‹©é€»è¾‘ (ä¿æŒä¸å˜) ---
                function renderFlagGallery() {
                    flagGallery.innerHTML = '';
                    FLAG_TEMPLATES_ARRAY.forEach(template => {
                        const item = document.createElement('div');
                        item.className = 'flag-item';
                        item.dataset.key = template.key;

                        if (template.key === currentFlagKey) {
                            item.classList.add('selected');
                        }
                        item.innerHTML = `
							<img src="${template.path}" alt="${template.name}" class="flag-preview-img">
							<p class="flag-name">${template.name}</p>
						`;
                        item.addEventListener('click', () => handleFlagSelection(template.key));
                        flagGallery.appendChild(item);
                    });
                }

                function handleFlagSelection(key) {
                    if (key === currentFlagKey) return;

                    currentFlagKey = key;
                    const template = FLAG_TEMPLATES[currentFlagKey];
                    const newPath = template.path;
                    const newScale = template.defaultScale || 1.0;

                    document.querySelectorAll('.flag-item').forEach(item => {
                        item.classList.remove('selected');
                        if (item.dataset.key === key) {
                            item.classList.add('selected');
                        }
                    });

                    flagImg.src = newPath;
                    resetFlagTransform(newScale);
                    saveState(); // åˆ‡æ¢æ——å¸œä¹Ÿä¿å­˜çŠ¶æ€
                }

                function initFlagSelector() {
                    renderFlagGallery();

                    if (!currentFlagKey) return;

                    flagImg.onload = () => {
                        if (originalImage) {
                            drawFlag();
                            saveState(true); // åˆå§‹åŠ è½½å›¾ç‰‡åä¿å­˜åˆå§‹çŠ¶æ€
                        }
                    };

                    const initialTemplate = FLAG_TEMPLATES[currentFlagKey];
                    flagImg.src = initialTemplate.path;
                    resetFlagTransform(initialTemplate.defaultScale || 1.0, false);
                }

                function resetFlagTransform(scale = 1.0, shouldSave = true) {
                    flagOffset = { x: 0, y: 0 };
                    flagRotation = 0;
                    flagStretch = { x: 1, y: 1 };
                    syncScale(scale, true); // ç¡®ä¿åŒæ­¥åˆ° UI
                    syncRotation(0, true); // ç¡®ä¿åŒæ­¥åˆ° UI
                    drawFlag();
                    if (shouldSave) saveState();
                }
                // ----------------------------------------

                // --- æ ¸å¿ƒç»˜å›¾å’Œäº¤äº’é€»è¾‘ ---

                function getPreviewTransform() {
                    if (!originalImage) return { scale: 1, offsetX: 0, offsetY: 0 };
                    // è®¡ç®—å¤´åƒåœ¨ 300x300 canvas ä¸­çš„ç¼©æ”¾æ¯”ä¾‹å’Œåç§»é‡ (ä¿æŒçºµæ¨ªæ¯”)
                    const scale = Math.min(CANVAS_SIZE / originalImage.width, CANVAS_SIZE / originalImage.height);
                    const offsetX = (CANVAS_SIZE - originalImage.width * scale) / 2;
                    const offsetY = (CANVAS_SIZE - originalImage.height * scale) / 2;
                    return { scale, offsetX, offsetY };
                }

                // å°† Preview Canvas åæ ‡ (300x300) è½¬æ¢ä¸º Process Canvas åæ ‡ (åŸå§‹å›¾ç‰‡åˆ†è¾¨ç‡)
                function previewToProcess(x, y) {
                    const t = getPreviewTransform();
                    return { x: (x - t.offsetX) / t.scale, y: (y - t.offsetY) / t.scale };
                }

                // å°† Process Canvas åæ ‡ (åŸå§‹å›¾ç‰‡åˆ†è¾¨ç‡) è½¬æ¢ä¸º Preview Canvas åæ ‡ (300x300)
                function processToPreview(x, y) {
                    const t = getPreviewTransform();
                    return { x: x * t.scale + t.offsetX, y: y * t.scale + t.offsetY };
                }

                function updateWrappers(hasImage) {
                    const wrappers = [originalWrapper, imageWrapper, circularWrapper];
                    wrappers.forEach(w => {
                        if (w) w.setAttribute('data-has-image', hasImage ? 'true' : 'false');
                    });
                }

                function processImageFile(file) {
                    if (!file) return;
                    fileName.textContent = file.name;
                    originalFileName = file.name.replace(/\.[^/.]+$/, "");
                    const reader = new FileReader();
                    reader.onload = e => {
                        const img = new Image();
                        img.onload = () => {
                            originalImage = img;
                            processCanvas.width = img.width;
                            processCanvas.height = img.height;
                            updateWrappers(true);
                            // é‡ç½®å†å²è®°å½•ï¼Œå¹¶ä¿å­˜åˆå§‹çŠ¶æ€
                            historyStack = [];
                            historyIndex = -1;
                            const initialTemplate = FLAG_TEMPLATES[currentFlagKey];
                            resetFlagTransform(initialTemplate.defaultScale || 1.0, false);
                            drawFlag();
                            downloadBtn.disabled = false;
                            saveState(true);
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                }


                function drawCircularPreview() {
                    if (!originalImage) return;

                    circularCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

                    circularCtx.save();
                    circularCtx.beginPath();
                    circularCtx.arc(CANVAS_SIZE / 2, CANVAS_SIZE / 2, CANVAS_SIZE / 2, 0, Math.PI * 2);
                    circularCtx.closePath();
                    circularCtx.clip();

                    // ä½¿ç”¨ processCanvas çš„å†…å®¹ä½œä¸ºåœ†å½¢é¢„è§ˆçš„æ¥æº
                    const t = getPreviewTransform();
                    circularCtx.drawImage(processCanvas, 0, 0, processCanvas.width, processCanvas.height, t.offsetX, t.offsetY, originalImage.width * t.scale, originalImage.height * t.scale);

                    circularCtx.restore(); // æ¢å¤å‰ªåˆ‡è·¯å¾„å‰çš„çŠ¶æ€
                    circularCtx.beginPath();
                    circularCtx.arc(CANVAS_SIZE / 2, CANVAS_SIZE / 2, CANVAS_SIZE / 2 - 1, 0, Math.PI * 2);
                    circularCtx.strokeStyle = '#007bff';
                    circularCtx.lineWidth = 2;
                    circularCtx.stroke();
                }


                // æ ¸å¿ƒç»˜å›¾å‡½æ•°
                function drawFlag() {
                    if (!originalImage || !flagImg.complete || flagImg.naturalWidth === 0) {
                        originalCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                        imageCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                        circularCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                        return;
                    }

                    const base = Math.min(originalImage.width, originalImage.height);
                    const flagBaseSize = base * FLAG_SIZE_RATIO;
                    const flagWidth = flagBaseSize * flagScale * flagStretch.x;
                    const flagHeight = (flagImg.height / flagImg.width) * flagBaseSize * flagScale * flagStretch.y;

                    let defaultX, defaultY;
                    const currentKey = currentFlagKey || '';

                    // è®¡ç®—é»˜è®¤çš„æ——å¸œä½ç½® (Process Canvas åæ ‡ç³»)
                    if (currentKey.startsWith('bottom')) {
                        defaultX = (originalImage.width - flagWidth) / 2;
                        defaultY = originalImage.height - flagHeight;
                    } else if (currentKey.startsWith('right_bottom')) {
                        defaultX = originalImage.width - flagWidth;
                        defaultY = originalImage.height - flagHeight;
                    } else {
                        defaultX = (originalImage.width - flagWidth) / 2;
                        defaultY = (originalImage.height - flagHeight) / 2;
                    }

                    // æœ€ç»ˆæ——å¸œä½ç½® (Process Canvas åæ ‡ç³»)
                    const x = defaultX + flagOffset.x;
                    const y = defaultY + flagOffset.y;

                    // flagRect å­˜å‚¨åœ¨ Process Canvas åæ ‡ç³»ä¸­çš„ä¿¡æ¯
                    flagRect = { x, y, width: flagWidth, height: flagHeight, cx: x + flagWidth / 2, cy: y + flagHeight / 2 };

                    // --- 1. ç»˜åˆ¶åˆ° Process Canvas (åŸå§‹åˆ†è¾¨ç‡) ---
                    processCtx.clearRect(0, 0, processCanvas.width, processCanvas.height);
                    processCtx.drawImage(originalImage, 0, 0);

                    processCtx.save();
                    processCtx.translate(flagRect.cx, flagRect.cy);
                    processCtx.rotate(flagRotation * Math.PI / 180);
                    processCtx.drawImage(flagImg, -flagWidth / 2, -flagHeight / 2, flagWidth, flagHeight);
                    processCtx.restore();

                    // --- 2. ç»˜åˆ¶åˆ° Preview Canvas (300x300, å®æ—¶é¢„è§ˆ) ---
                    updatePreviews();
                }

                // æ›´æ–°æ‰€æœ‰ 300x300 é¢„è§ˆæ¡†
                function updatePreviews() {
                    if (!originalImage) return;

                    const t = getPreviewTransform();

                    // ç»˜åˆ¶åŸå§‹å¤´åƒåˆ° Original Canvas (åªè¯»åŒº) - ä¿æŒåŸå§‹å¤´åƒä¸å˜
                    originalCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                    originalCtx.drawImage(originalImage, 0, 0, originalImage.width, originalImage.height, t.offsetX, t.offsetY, originalImage.width * t.scale, originalImage.height * t.scale);


                    // ç»˜åˆ¶ Process Canvas (åŒ…å«æ——å¸œ) åˆ° Image Canvas (å¤„ç†å¤´åƒ-æ–¹, å¯ç¼–è¾‘åŒº)
                    imageCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                    imageCtx.drawImage(processCanvas, 0, 0, processCanvas.width, processCanvas.height, t.offsetX, t.offsetY, originalImage.width * t.scale, originalImage.height * t.scale);
                    drawControls(imageCtx); // åœ¨å¯ç¼–è¾‘åŒºç»˜åˆ¶æ§åˆ¶ç‚¹

                    // ç»˜åˆ¶åœ†å½¢é¢„è§ˆ (å¤„ç†å¤´åƒ-åœ†, å¯ç¼–è¾‘åŒº)
                    drawCircularPreview();
                    drawControls(circularCtx); // åœ¨å¯ç¼–è¾‘åŒºç»˜åˆ¶æ§åˆ¶ç‚¹
                }

                // ç»˜åˆ¶æ——å¸œè¾¹æ¡†å’Œæ§åˆ¶ç‚¹ (æ¥å—ä¸€ä¸ª ctx å‚æ•°)
                function drawControls(ctx) {
                    if (!originalImage || !flagImg.complete || flagImg.naturalWidth === 0) return;

                    const t = getPreviewTransform();
                    const scaleFactor = t.scale;

                    // è®¡ç®— Process Canvas åæ ‡ç³»ä¸­æ——å¸œçŸ©å½¢çš„å››ä¸ªè§’ (ç›¸å¯¹äº Process Canvas åŸç‚¹)
                    const w = flagRect.width;
                    const h = flagRect.height;
                    const cx = flagRect.cx;
                    const cy = flagRect.cy;
                    const angle = flagRotation * Math.PI / 180;

                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);

                    // æ—‹è½¬åçš„å››ä¸ªè§’ (åœ¨ Process Canvas åæ ‡ç³»ä¸­)
                    const corners = [
                        { x: -w / 2, y: -h / 2 },
                        { x: w / 2, y: -h / 2 },
                        { x: w / 2, y: h / 2 },
                        { x: -w / 2, y: h / 2 }
                    ].map(p => {
                        const rotatedX = p.x * cos - p.y * sin;
                        const rotatedY = p.x * sin + p.y * cos;
                        return { x: rotatedX + cx, y: rotatedY + cy };
                    });

                    // æ—‹è½¬åçš„ä¸­ç‚¹ (åœ¨ Process Canvas åæ ‡ç³»ä¸­)
                    const midTop = {
                        x: cx + (0) * cos - (-h / 2) * sin,
                        y: cy + (0) * sin + (-h / 2) * cos
                    };

                    // --- ç»˜åˆ¶è¾¹æ¡†å’Œæ—‹è½¬æ‰‹æŸ„ ---

                    ctx.strokeStyle = activeControlPoint === 'center' ? 'red' : '#007bff';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);

                    ctx.beginPath();
                    let p = processToPreview(corners[0].x, corners[0].y);
                    ctx.moveTo(p.x, p.y);
                    for (let i = 1; i < corners.length; i++) {
                        p = processToPreview(corners[i].x, corners[i].y);
                        ctx.lineTo(p.x, p.y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    ctx.setLineDash([]); // æ¢å¤å®çº¿

                    // ç»˜åˆ¶æ—‹è½¬æ‰‹æŸ„
                    const midTopPreview = processToPreview(midTop.x, midTop.y);
                    const rotationHandleEnd = {
                        x: midTop.x + sin * ROTATION_HANDLE_LENGTH / scaleFactor, // æ—‹è½¬æ‰‹æŸ„çš„ç»ˆç‚¹ (Process)
                        y: midTop.y - cos * ROTATION_HANDLE_LENGTH / scaleFactor
                    };
                    const rotationHandleEndPreview = processToPreview(rotationHandleEnd.x, rotationHandleEnd.y);

                    ctx.beginPath();
                    ctx.moveTo(midTopPreview.x, midTopPreview.y);
                    ctx.lineTo(rotationHandleEndPreview.x, rotationHandleEndPreview.y);
                    ctx.strokeStyle = activeControlPoint === 'rotate' ? 'red' : '#ff9800';
                    ctx.lineWidth = 3;
                    ctx.stroke();

                    // --- ç»˜åˆ¶æ§åˆ¶ç‚¹ (æ‹–åŠ¨å’Œç¼©æ”¾) ---

                    // æ‹–åŠ¨ä¸­å¿ƒç‚¹ (Center Handle)
                    const centerPreview = processToPreview(cx, cy);
                    controlPoints.center = centerPreview;
                    ctx.beginPath();
                    ctx.arc(centerPreview.x, centerPreview.y, CONTROL_POINT_RADIUS, 0, Math.PI * 2);
                    ctx.fillStyle = activeControlPoint === 'center' ? 'red' : 'rgba(0, 123, 255, 0.8)';
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // ç¼©æ”¾/æ—‹è½¬æ§åˆ¶ç‚¹ (Scale/Rotate Handle)
                    const scaleHandlePos = processToPreview(corners[1].x, corners[1].y); // å³ä¸Šè§’ä½œä¸ºç¼©æ”¾ç‚¹
                    const rotateHandlePos = rotationHandleEndPreview; // æ—‹è½¬æ‰‹æŸ„ç»ˆç‚¹ä½œä¸ºæ—‹è½¬ç‚¹

                    controlPoints.scale = scaleHandlePos;
                    controlPoints.rotate = rotateHandlePos;

                    // ç»˜åˆ¶ç¼©æ”¾ç‚¹
                    ctx.beginPath();
                    ctx.arc(scaleHandlePos.x, scaleHandlePos.y, CONTROL_POINT_RADIUS, 0, Math.PI * 2);
                    ctx.fillStyle = activeControlPoint === 'scale' ? 'red' : 'rgba(255, 0, 0, 0.9)';
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // ç»˜åˆ¶æ—‹è½¬ç‚¹
                    ctx.beginPath();
                    ctx.arc(rotateHandlePos.x, rotateHandlePos.y, CONTROL_POINT_RADIUS, 0, Math.PI * 2);
                    ctx.fillStyle = activeControlPoint === 'rotate' ? 'red' : 'rgba(255, 152, 0, 0.9)';
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // æ£€æŸ¥é¼ æ ‡/è§¦æ‘¸æ˜¯å¦åœ¨æ§åˆ¶ç‚¹é™„è¿‘
                function getControlPoint(x, y) {
                    if (!controlPoints.center) return null;

                    const points = [
                        { key: 'scale', pos: controlPoints.scale },
                        { key: 'rotate', pos: controlPoints.rotate },
                    ];

                    // ä¼˜å…ˆæ£€æŸ¥ç¼©æ”¾/æ—‹è½¬ç‚¹
                    for (const p of points) {
                        const dist = Math.hypot(x - p.pos.x, y - p.pos.y);
                        // å¢å¤§è§¦æ‘¸ç‚¹å‡»åŒºåŸŸ (CONTROL_POINT_RADIUS + 5)
                        if (dist <= CONTROL_POINT_RADIUS + 10) { 
                            return p.key;
                        }
                    }

                    // æ£€æŸ¥æ‹–åŠ¨ç‚¹
                    const distCenter = Math.hypot(x - controlPoints.center.x, y - controlPoints.center.y);
                    if (distCenter <= CONTROL_POINT_RADIUS + 10) {
                        return 'center';
                    }

                    // æ£€æŸ¥æ˜¯å¦åœ¨æ——å¸œè¾¹æ¡†å†… (è¿‘ä¼¼çŸ©å½¢æ£€æŸ¥ï¼Œç®€åŒ–å¤„ç†)
                    const t = getPreviewTransform();
                    const flagPreview = {
                        x: processToPreview(flagRect.x, flagRect.y).x,
                        y: processToPreview(flagRect.y, flagRect.y).y,
                        w: flagRect.width * t.scale,
                        h: flagRect.height * t.scale,
                    };

                    // ç®€åŒ–çŸ©å½¢æ£€æŸ¥ï¼Œå¿½ç•¥æ—‹è½¬ï¼Œåªæ£€æŸ¥æ˜¯å¦åœ¨ç•Œå†…
                    const isInsideFlag = x >= flagPreview.x - 10 && x <= flagPreview.x + flagPreview.w + 10 &&
                        y >= flagPreview.y - 10 && y <= flagPreview.y + flagPreview.h + 10;
                    
                    if (isInsideFlag) {
                        return 'flag_body';
                    }


                    return null;
                }

                // é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶
                function handleMouseDown(e) {
                    if (!originalImage) return;

                    // ç¡®ä¿åªåœ¨ imageCanvas æˆ– circularCanvas ä¸Šè§¦å‘äº¤äº’
                    if (e.target !== imageCanvas && e.target !== circularCanvas) return;

                    e.preventDefault();
                    isDragging = true;
                    lastMouse = { x: e.offsetX, y: e.offsetY };
                    dragStart = { x: flagOffset.x, y: flagOffset.y };
                    startScale = flagScale;
                    startRotation = flagRotation;

                    activeControlPoint = getControlPoint(e.offsetX, e.offsetY);

                    if (activeControlPoint === 'center' || activeControlPoint === 'flag_body') {
                        activeControlPoint = 'center'; // å°†ç‚¹å‡»æ——å¸œä¸»ä½“ä¹Ÿè§†ä¸ºæ‹–åŠ¨
                        imageCanvas.style.cursor = 'move';
                        circularCanvas.style.cursor = 'move';
                    } else if (activeControlPoint === 'scale') {
                        imageCanvas.style.cursor = 'nwse-resize';
                        circularCanvas.style.cursor = 'nwse-resize';
                        isTransforming = true;
                    } else if (activeControlPoint === 'rotate') {
                        imageCanvas.style.cursor = 'crosshair';
                        circularCanvas.style.cursor = 'crosshair';
                        isTransforming = true;
                    } else {
                        isDragging = false;
                        isTransforming = false;
                        imageCanvas.style.cursor = 'pointer';
                        circularCanvas.style.cursor = 'pointer';
                        return;
                    }
                    drawFlag(); // ç»˜åˆ¶é€‰ä¸­çŠ¶æ€
                }

                // é¼ æ ‡ç§»åŠ¨äº‹ä»¶
                function handleMouseMove(e) {
                    if (!originalImage) return;

                    const currentMouse = { x: e.offsetX, y: e.offsetY };
                    const t = getPreviewTransform();

                    if (isDragging) {
                        const dx = currentMouse.x - lastMouse.x;
                        const dy = currentMouse.y - lastMouse.y;

                        if (activeControlPoint === 'center') {
                            // æ‹–åŠ¨ï¼šå°† Canvas åæ ‡ç³»çš„å¢é‡è½¬æ¢åˆ° Process Canvas åæ ‡ç³»
                            const deltaX_proc = dx / t.scale;
                            const deltaY_proc = dy / t.scale;

                            flagOffset.x += deltaX_proc;
                            flagOffset.y += deltaY_proc;
                            drawFlag();
                            deferredSaveState(); // å»¶è¿Ÿä¿å­˜çŠ¶æ€
                        } else if (activeControlPoint === 'scale' || activeControlPoint === 'rotate') {
                            // ç¼©æ”¾/æ—‹è½¬
                            const cx = controlPoints.center.x;
                            const cy = controlPoints.center.y;
                            const currentAngle = Math.atan2(currentMouse.y - cy, currentMouse.x - cx);
                            const lastAngle = Math.atan2(lastMouse.y - cy, lastMouse.x - cx);
                            const angleDelta = currentAngle - lastAngle;

                            const currentDist = Math.hypot(currentMouse.x - cx, currentMouse.y - cy);
                            const lastDist = Math.hypot(lastMouse.x - cx, lastMouse.y - cy);
                            const distRatio = currentDist / lastDist;

                            if (activeControlPoint === 'rotate') {
                                // æ—‹è½¬ï¼šè½¬æ¢ä¸ºåº¦æ•°
                                flagRotation = (startRotation + angleDelta * 180 / Math.PI) % 360;
                                syncRotation(flagRotation, true);
                            }

                            if (activeControlPoint === 'scale') {
                                // ç¼©æ”¾ï¼šåŸºäºè·ç¦»æ¯”
                                flagScale = startScale * distRatio;
                                syncScale(flagScale, true);
                            }

                            drawFlag();
                            deferredSaveState(); // å»¶è¿Ÿä¿å­˜çŠ¶æ€
                        }

                        lastMouse = currentMouse;
                    } else {
                        // ä»…ç§»åŠ¨æ—¶æ›´æ–°å…‰æ ‡
                        const point = getControlPoint(currentMouse.x, currentMouse.y);
                        if (e.target === imageCanvas || e.target === circularCanvas) {
                            if (point === 'center' || point === 'flag_body') {
                                e.target.style.cursor = 'move';
                            } else if (point === 'scale') {
                                e.target.style.cursor = 'nwse-resize';
                            } else if (point === 'rotate') {
                                e.target.style.cursor = 'crosshair';
                            } else {
                                e.target.style.cursor = 'pointer';
                            }
                        }
                    }
                }

                // é¼ æ ‡æŠ¬èµ·äº‹ä»¶
                function handleMouseUp(e) {
                    if (isDragging) {
                        isDragging = false;
                        isTransforming = false;
                        imageCanvas.style.cursor = 'pointer';
                        circularCanvas.style.cursor = 'pointer';
                        if (activeControlPoint) {
                            activeControlPoint = null;
                            drawFlag(); // ç»˜åˆ¶éé€‰ä¸­çŠ¶æ€
                            saveState(); // æ‹–åŠ¨/ç¼©æ”¾ç»“æŸåä¿å­˜çŠ¶æ€
                        }
                    }
                }
                
                // --- æ–°å¢ï¼šè§¦æ‘¸äº‹ä»¶å¤„ç†å‡½æ•° ---

                function getTouchPos(e) {
                    // ç¡®ä¿ä½¿ç”¨ç¬¬ä¸€ä¸ªè§¦æ‘¸ç‚¹
                    const touch = e.touches[0] || e.changedTouches[0];
                    const rect = touch.target.getBoundingClientRect();
                    return {
                        x: touch.clientX - rect.left,
                        y: touch.clientY - rect.top,
                    };
                }

                function handleTouchStart(e) {
                    if (!originalImage) return;

                    // ç¡®ä¿åªåœ¨ imageCanvas æˆ– circularCanvas ä¸Šè§¦å‘äº¤äº’ï¼Œå¹¶ä¸”åªæœ‰ä¸€ä¸ªè§¦æ‘¸ç‚¹
                    if (e.target !== imageCanvas && e.target !== circularCanvas || e.touches.length > 1) return;

                    e.preventDefault(); // é˜»æ­¢é»˜è®¤çš„æ»šåŠ¨è¡Œä¸º
                    isDragging = true;

                    const touchPos = getTouchPos(e);
                    lastMouse = touchPos;
                    dragStart = { x: flagOffset.x, y: flagOffset.y };
                    startScale = flagScale;
                    startRotation = flagRotation;

                    activeControlPoint = getControlPoint(touchPos.x, touchPos.y);

                    if (activeControlPoint === 'center' || activeControlPoint === 'flag_body') {
                        activeControlPoint = 'center'; // å°†ç‚¹å‡»æ——å¸œä¸»ä½“ä¹Ÿè§†ä¸ºæ‹–åŠ¨
                    } else if (activeControlPoint === 'scale' || activeControlPoint === 'rotate') {
                        isTransforming = true;
                    } else {
                        isDragging = false;
                        isTransforming = false;
                        return;
                    }
                    drawFlag(); // ç»˜åˆ¶é€‰ä¸­çŠ¶æ€
                }

                function handleTouchMove(e) {
                    if (!originalImage || !isDragging || e.touches.length > 1) return;

                    e.preventDefault(); // é˜»æ­¢é»˜è®¤çš„æ»šåŠ¨è¡Œä¸º

                    const currentMouse = getTouchPos(e);
                    const t = getPreviewTransform();

                    const dx = currentMouse.x - lastMouse.x;
                    const dy = currentMouse.y - lastMouse.y;

                    if (activeControlPoint === 'center') {
                        // æ‹–åŠ¨
                        const deltaX_proc = dx / t.scale;
                        const deltaY_proc = dy / t.scale;

                        flagOffset.x += deltaX_proc;
                        flagOffset.y += deltaY_proc;
                        drawFlag();
                        deferredSaveState();
                    } else if (activeControlPoint === 'scale' || activeControlPoint === 'rotate') {
                        // ç¼©æ”¾/æ—‹è½¬
                        const cx = controlPoints.center.x;
                        const cy = controlPoints.center.y;
                        const currentAngle = Math.atan2(currentMouse.y - cy, currentMouse.x - cx);
                        const lastAngle = Math.atan2(lastMouse.y - cy, lastMouse.x - cx);
                        const angleDelta = currentAngle - lastAngle;

                        const currentDist = Math.hypot(currentMouse.x - cx, currentMouse.y - cy);
                        const lastDist = Math.hypot(lastMouse.x - cx, lastMouse.y - cy);
                        const distRatio = currentDist / lastDist;

                        if (activeControlPoint === 'rotate') {
                            flagRotation = (startRotation + angleDelta * 180 / Math.PI) % 360;
                            syncRotation(flagRotation, true);
                        }

                        if (activeControlPoint === 'scale') {
                            flagScale = startScale * distRatio;
                            syncScale(flagScale, true);
                        }

                        drawFlag();
                        deferredSaveState();
                    }

                    lastMouse = currentMouse;
                }

                function handleTouchEnd(e) {
                    if (isDragging) {
                        isDragging = false;
                        isTransforming = false;
                        if (activeControlPoint) {
                            activeControlPoint = null;
                            drawFlag(); // ç»˜åˆ¶éé€‰ä¸­çŠ¶æ€
                            saveState(); // æ‹–åŠ¨/ç¼©æ”¾ç»“æŸåä¿å­˜çŠ¶æ€
                        }
                    }
                }
                // --- è§¦æ‘¸äº‹ä»¶å¤„ç†å‡½æ•°ç»“æŸ ---


                // --- ä¸‹è½½é€»è¾‘ ---
                function downloadImage(type = 'square') {
                    if (!originalImage) return;

                    // ä½¿ç”¨ processCanvas (åŸå§‹åˆ†è¾¨ç‡)
                    if (type === 'square') {
                        const url = processCanvas.toDataURL('image/png');
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${originalFileName}_deal.png`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                    } else if (type === 'circular') {
                        // ç¦»å± Canvas ç”¨äºåœ†å½¢è£å‰ª
                        const finalCanvas = document.createElement('canvas');
                        const finalCtx = finalCanvas.getContext('2d');
                        const size = Math.min(processCanvas.width, processCanvas.height);
                        finalCanvas.width = size;
                        finalCanvas.height = size;
                        const centerX = processCanvas.width / 2;
                        const centerY = processCanvas.height / 2;
                        const radius = size / 2;

                        finalCtx.beginPath();
                        finalCtx.arc(radius, radius, radius, 0, Math.PI * 2);
                        finalCtx.closePath();
                        finalCtx.clip();

                        // ç»˜åˆ¶ Process Canvas çš„å†…å®¹ï¼Œä»¥ä¸­å¿ƒå¯¹é½
                        finalCtx.drawImage(
                            processCanvas,
                            centerX - radius, // sx
                            centerY - radius, // sy
                            size,             // sWidth
                            size,             // sHeight
                            0, 0, size, size  // dx, dy, dWidth, dHeight
                        );

                        const url = finalCanvas.toDataURL('image/png');
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${originalFileName}_flag_circular.png`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                    }
                }

                downloadBtn.addEventListener('click', () => {
                    downloadImage('square');
                });


                // --- æ–‡ä»¶/æ‹–æ”¾äº‹ä»¶ ---
                avatarUpload.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        processImageFile(e.target.files[0]);
                    }
                });

                dropArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    dropArea.classList.add('drag-over');
                });

                dropArea.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    dropArea.classList.remove('drag-over');
                });

                dropArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dropArea.classList.remove('drag-over');
                    if (e.dataTransfer.files.length > 0) {
                        const file = e.dataTransfer.files[0];
                        if (file.type.startsWith('image/')) {
                            processImageFile(file);
                        } else {
                            alert('è¯·æ‹–æ”¾å›¾ç‰‡æ–‡ä»¶ã€‚');
                        }
                    }
                });


                // --- äº¤äº’äº‹ä»¶ç»‘å®š (åœ¨ Canvas å®¹å™¨ä¸Šç›‘å¬ï¼Œä»¥æ•è·æ•´ä¸ª 300x300 åŒºåŸŸçš„äº‹ä»¶) ---
                imageCanvas.addEventListener('mousedown', handleMouseDown);
                circularCanvas.addEventListener('mousedown', handleMouseDown);
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
                
                // *** å…³é”®ä¿®å¤ï¼šæ–°å¢è§¦æ‘¸äº‹ä»¶ç›‘å¬å™¨ ***
                imageCanvas.addEventListener('touchstart', handleTouchStart);
                circularCanvas.addEventListener('touchstart', handleTouchStart);
                document.addEventListener('touchmove', handleTouchMove, { passive: false }); // å¿…é¡»è®¾ç½®ä¸º false æ‰èƒ½è°ƒç”¨ preventDefault
                document.addEventListener('touchend', handleTouchEnd);
                document.addEventListener('touchcancel', handleTouchEnd); // è§¦æ‘¸ä¸­æ–­ä¹Ÿè§†ä¸ºç»“æŸ
                // **********************************

                // é”®ç›˜å¿«æ·é”® (æ’¤é”€/é‡åš)
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        if (e.key === 'z') { // Ctrl+Z / Cmd+Z (æ’¤é”€)
                            e.preventDefault();
                            if (historyIndex > 0) {
                                historyIndex--;
                                loadState(historyStack[historyIndex]);
                            }
                        } else if (e.key === 'y') { // Ctrl+Y / Cmd+Y (é‡åš)
                            e.preventDefault();
                            if (historyIndex < historyStack.length - 1) {
                                historyIndex++;
                                loadState(historyStack[historyIndex]);
                            }
                        }
                    }
                });

                function loadState(state) {
                    flagOffset = { ...state.flagOffset };
                    syncScale(state.flagScale, true);
                    syncRotation(state.flagRotation, true);

                    if (state.currentFlagKey !== currentFlagKey) {
                        const template = FLAG_TEMPLATES[state.currentFlagKey];
                        if (template) {
                            currentFlagKey = state.currentFlagKey;
                            flagImg.src = template.path; // é‡æ–°åŠ è½½æ——å¸œå›¾ç‰‡
                            renderFlagGallery(); // æ›´æ–°é€‰æ‹©çŠ¶æ€
                            // flagImg.onload ä¼šè§¦å‘ drawFlagï¼Œä½†ä¸ºç¡®ä¿ç«‹å³æ›´æ–°ï¼Œåœ¨ä¸»å›¾åŠ è½½å®Œæˆåä¹Ÿå¼ºåˆ¶è°ƒç”¨ä¸€æ¬¡
                            if (flagImg.complete && flagImg.naturalWidth !== 0) {
                                drawFlag();
                            }
                        }
                    } else {
                        drawFlag();
                    }
                }


                // --- åŠ¨æ€è·å–è´¡çŒ®è€…ä¿¡æ¯ (é‡‡çº³ç”¨æˆ·å»ºè®®) ---
                function fetchContributors() {
                    const repo = 'bghtnya/TransFlag_Avatar_Tool';
                    const url = `https://api.github.com/repos/${repo}/contributors`;
                    const container = document.getElementById('contributorsContainer');

                    // åˆå§‹æ˜¾ç¤ºåŠ è½½ä¿¡æ¯
                    container.innerHTML = '<h3>é¡¹ç›®è´¡çŒ®è€…</h3><p>æ­£åœ¨åŠ è½½è´¡çŒ®è€…ä¿¡æ¯...</p>';

                    fetch(url)
                        .then(response => {
                            if (!response.ok) {
                                // å¦‚æœ API è°ƒç”¨å¤±è´¥ï¼ˆä¾‹å¦‚è¾¾åˆ°é€Ÿç‡é™åˆ¶ï¼‰ï¼Œè¿”å›é”™è¯¯
                                throw new Error(`GitHub API error: ${response.statusText}`);
                            }
                            return response.json();
                        })
                        .then(contributors => {
                            // è¿‡æ»¤æ‰ GitHub Actions æˆ–å…¶ä»–è‡ªåŠ¨åŒ–æœºå™¨äºº
                            const humanContributors = contributors.filter(c => c.type === 'User');

                            if (humanContributors.length === 0) {
                                container.innerHTML = '<h3>é¡¹ç›®è´¡çŒ®è€…</h3><p>æš‚æ— è´¡çŒ®è€…ä¿¡æ¯ã€‚</p>';
                                return;
                            }

                            const listItems = humanContributors.map(contributor => `
                                <li class="contributor-item">
                                    <img src="${contributor.avatar_url}" alt="${contributor.login}'s avatar" class="contributor-avatar">
                                    <a href="${contributor.html_url}" target="_blank" class="contributor-login">${contributor.login}</a>
                                </li>
                            `).join('');

                            container.innerHTML = `
                                <h3>é¡¹ç›®è´¡çŒ®è€…</h3>
                                <ul class="contributor-list">
                                    ${listItems}
                                </ul>
                            `;
                        })
                        .catch(error => {
                            console.error("Failed to fetch contributors:", error);
                            container.innerHTML = '<h3>é¡¹ç›®è´¡çŒ®è€…</h3><p>æ— æ³•åŒæ­¥è´¡çŒ®è€…ä¿¡æ¯ã€‚è¯·è®¿é—®é¡¹ç›®ä»“åº“æŸ¥çœ‹ã€‚</p>';
                        });
                }


                // --- åˆå§‹å¯åŠ¨ ---
                initFlagSelector();
                updateWrappers(false); // åˆå§‹çŠ¶æ€æ²¡æœ‰å›¾ç‰‡

                // åœ¨é¡µé¢åŠ è½½å®Œæ¯•åç«‹å³è°ƒç”¨
                fetchContributors();
            });
        </script>
    </div>
</body>

</html>