<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TransFlag Avatar Tool â€” å¤šæ——å¸œ & è´´çº¸ & ä½ç½®</title>
  <style>
    :root{--accent:#3b82f6;--bg:#0f172a;color-scheme:light}
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial}
    body{display:flex;gap:16px;padding:18px;background:linear-gradient(180deg,#f8fafc,#eef2ff)}
    .panel{width:360px;background:#fff;border-radius:12px;padding:14px;box-shadow:0 6px 18px rgba(2,6,23,0.08)}
    h2{margin:6px 0 10px;font-size:16px}
    label{display:block;margin:8px 0;font-size:13px}
    .preview{flex:1;display:flex;flex-direction:column;gap:10px}
    .canvas-wrap{background:#eef2ff;border-radius:12px;padding:12px;display:flex;justify-content:center;align-items:center;position:relative;}
    canvas{border-radius:8px;background:#fff}
    .flag-list{display:flex;flex-wrap:wrap;gap:8px}
    .flag-item{padding:6px 8px;border-radius:8px;background:#f8fafc;cursor:pointer;font-size:13px}
    .flag-item.active{box-shadow:inset 0 0 0 2px var(--accent);font-weight:600}
    .stickers{display:flex;gap:8px;flex-wrap:wrap}
    .sticker-btn{font-size:20px;padding:6px;border-radius:8px;background:#fff;border:1px solid #eee;cursor:pointer}
    .controls{display:flex;gap:8px;align-items:center}
    .row{display:flex;gap:8px;align-items:center}
    select,input[type=range]{width:100%}
    button{background:var(--accent);color:#fff;padding:8px 12px;border-radius:10px;border:0;cursor:pointer}
    small{color:#6b7280}
    .sticker-list{display:flex;flex-direction:column;gap:8px;margin-top:8px}
    .sticker-entry{display:flex;gap:8px;align-items:center}
    .sticker-thumb{width:48px;height:48px;border-radius:6px;background:#fff;display:flex;align-items:center;justify-content:center;border:1px solid #eee}
    .muted{color:#9ca3af;font-size:13px}
    
    /* æ–°å¢ï¼šä½¿ canvas å®¹å™¨æ”¯æŒç›¸å¯¹å®šä½ï¼Œä»¥ä¾¿æ›´å¥½åœ°æ§åˆ¶æ‹–åŠ¨ */
    .canvas-wrap { position: relative; }
  </style>
</head>
<body>
  <div class="panel">
    <h2>è®¾ç½®ï¼ˆFlags & Stickersï¼‰</h2>

    <label>é€‰æ‹©æ——å¸œ</label>
    <div class="flag-list" id="flagList"></div>

    <label>æˆ–ä¸Šä¼ è‡ªå®šä¹‰æ——å¸œ</label>
    <input id="uploadFlag" type="file" accept="image/*" />

    <label style="margin-top:10px">é€‰æ‹©è´´çº¸ï¼ˆå¯å¤šé€‰ï¼‰</label>
    <div class="stickers" id="emojiStickers">
      <button class="sticker-btn" data-emoji="ğŸ¥">ğŸ¥</button>
      <button class="sticker-btn" data-emoji="ğŸ’Š">ğŸ’Š</button>
      <button class="sticker-btn" data-emoji="ğŸŒˆ">ğŸŒˆ</button>
      <button class="sticker-btn" data-emoji="â¤ï¸">â¤ï¸</button>
    </div>

    <label>æˆ–ä¸Šä¼ å›¾ç‰‡ä½œä¸ºè´´çº¸</label>
    <input id="uploadSticker" type="file" accept="image/*" />

    <label style="margin-top:8px">æ——å¸œ/è´´çº¸ **é¢„è®¾** ä½ç½®ï¼ˆåº”ç”¨äºæœ€åæ·»åŠ æˆ–é€‰ä¸­çš„å¯¹è±¡ï¼‰</label>
    <select id="positionSelect">
      <option value="none">æ— ï¼ˆè‡ªç”±ç§»åŠ¨ï¼‰</option>
      <option value="bottom-right">å³ä¸‹è§’</option>
      <option value="bottom-left">å·¦ä¸‹è§’</option>
      <option value="top-right">å³ä¸Šè§’</option>
      <option value="top-left">å·¦ä¸Šè§’</option>
      <option value="bottom">åº•éƒ¨å±…ä¸­</option>
      <option value="top">é¡¶éƒ¨å±…ä¸­</option>
      <option value="full-cover">æ——å¸œï¼šå…¨è¦†ç›–</option>
      <option value="corner-ribbon" selected>æ——å¸œï¼šå³ä¸‹è§’æ–œè§’ï¼ˆé»˜è®¤ï¼‰</option>
    </select>

    <label>å¯¹è±¡å®½åº¦ <small id="sizeLabel">40</small> px</label>
    <input id="sizeRange" type="range" min="16" max="512" value="40" />

    <label>å¯¹è±¡é€æ˜åº¦ <small id="opLabel">1.00</small></label>
    <input id="opacityRange" type="range" min="0" max="1" step="0.01" value="1" />

    <div style="display:flex;gap:8px;margin-top:12px">
      <button id="downloadBtn">å¯¼å‡º PNG</button>
      <button id="resetBtn" style="background:#64748b">é‡ç½®</button>
    </div>

    <p class="muted" style="margin-top:10px">æç¤ºï¼šç‚¹å‡»å¯¹è±¡å¯é€‰ä¸­ã€‚å¯æ‹–åŠ¨ã€ç¼©æ”¾ã€æ‹‰ä¼¸å¯¹è±¡ã€‚</p>
  </div>

  <div class="preview">
    <h2>é¢„è§ˆ</h2>
    <div class="canvas-wrap">
      <canvas id="canvas" width="512" height="512"></canvas>
    </div>

    <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
      <label style="width:88px">ä¸Šä¼ å¤´åƒ</label>
      <input id="avatarInput" type="file" accept="image/*" />
      <small class="muted">æœªä¸Šä¼ æ—¶å°†ä½¿ç”¨å ä½å¤´åƒ</small>
    </div>

    <div class="sticker-list" id="stickerList"></div>
  </div>

<script>
// --- æ•°æ®ä¸é»˜è®¤å‚æ•° ---
const FLAGS = [
  { id:'none', name:'æ— æ——å¸œ' },
  { id:'trans', name:'è·¨æ€§åˆ«æ——' },
  { id:'lesbian', name:'å¥³åŒæ——' },
  { id:'bi', name:'åŒæ€§æ‹æ——' },
  { id:'nonbinary', name:'éäºŒå…ƒæ——' }
];

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let avatarImg = null;
let nextObjectId = 1; // ç”¨äºè´´çº¸çš„ID

// Flag object: {id:0, type:'flag', flagId, img?, x, y, w, h, opacity, rotation, locked}
let flagObject = null; 

// Stickers and Flags combined for drawing and interaction. ID 0 is reserved for the flag.
let objects = []; // {id: 1+, type:'emoji'|'image', emoji?, img?, x, y, w, h, opacity, rotation, locked}

const state = {
  selectedFlagId: 'none',
  presetPosition: 'corner-ribbon',
  selectedObjectId: null // å½“å‰é€‰ä¸­çš„å¯¹è±¡IDï¼Œnull è¡¨ç¤ºæœªé€‰ä¸­
};

// --- UI init ---
const flagList = document.getElementById('flagList');
for(const f of FLAGS){
  const b = document.createElement('div');
  b.className='flag-item' + (f.id==='none'?' active':'');
  b.textContent=f.name;
  b.dataset.id=f.id;
  b.onclick = ()=>{ 
    selectFlag(f.id); 
    document.querySelectorAll('.flag-item').forEach(el=>el.classList.remove('active')); 
    b.classList.add('active'); 
  };
  flagList.appendChild(b);
}

document.getElementById('uploadFlag').addEventListener('change', ev=>{
  const f = ev.target.files && ev.target.files[0];
  if(!f) return;
  const url = URL.createObjectURL(f);
  const img = new Image(); 
  img.onload = ()=>{ 
    addFlagObject('custom', img);
    state.selectedFlagId = 'custom';
    document.querySelectorAll('.flag-item').forEach(el=>el.classList.remove('active'));
    render(); 
    URL.revokeObjectURL(url); 
  };
  img.src = url;
});

// stickers
document.getElementById('emojiStickers').addEventListener('click', ev=>{
  const btn = ev.target.closest('[data-emoji]');
  if(!btn) return;
  addEmojiSticker(btn.dataset.emoji);
});

document.getElementById('uploadSticker').addEventListener('change', ev=>{
  const f = ev.target.files && ev.target.files[0]; 
  if(!f) return; 
  const url = URL.createObjectURL(f); 
  const img = new Image(); 
  img.onload=()=>{ addImageSticker(img); URL.revokeObjectURL(url); }; 
  img.src=url; 
  ev.target.value='';
});

// avatar
document.getElementById('avatarInput').addEventListener('change', ev=>{
  const f = ev.target.files && ev.target.files[0]; 
  if(!f) return; 
  const url = URL.createObjectURL(f); 
  const img=new Image(); 
  img.onload=()=>{ 
    avatarImg=img; render(); 
    URL.revokeObjectURL(url); 
  }; 
  img.src=url; 
  ev.target.value='';
});

// controls
const posSel = document.getElementById('positionSelect'); 
posSel.value = state.presetPosition;
posSel.addEventListener('change',e=>{ 
  state.presetPosition=e.target.value; 
  applyPresetPosition(); 
  render(); 
});

const sizeRange = document.getElementById('sizeRange'); 
const sizeLabel = document.getElementById('sizeLabel'); 
sizeRange.addEventListener('input',e=>{ 
  const newSize = Number(e.target.value);
  sizeLabel.textContent=newSize; 
  applySizeToSelected(newSize); 
  render(); 
});

const opRange = document.getElementById('opacityRange'); 
const opLabel = document.getElementById('opLabel'); 
opRange.addEventListener('input',e=>{ 
  const newOpacity = Number(e.target.value);
  opLabel.textContent=newOpacity.toFixed(2); 
  applyOpacityToSelected(newOpacity); 
  render(); 
});

document.getElementById('downloadBtn').addEventListener('click', ()=>{ downloadPNG(); });
document.getElementById('resetBtn').addEventListener('click', ()=>{ resetAll(); });

// sticker list management UI
const stickerListEl = document.getElementById('stickerList');
function refreshStickerList(){
  stickerListEl.innerHTML='';
  // Combine flag and stickers for list display
  const allObjects = (flagObject ? [flagObject] : []).concat(objects);

  allObjects.forEach(s=>{
    const isFlag = s.type === 'flag';
    const e = document.createElement('div'); 
    e.className='sticker-entry' + (s.id === state.selectedObjectId ? ' active' : '');
    e.onclick = () => { 
      state.selectedObjectId = s.id; 
      refreshStickerList(); 
      render(); // Redraw to show selection box
      // Update controls to match selected object
      sizeRange.value = s.w; sizeLabel.textContent = s.w;
      opRange.value = s.opacity; opLabel.textContent = s.opacity.toFixed(2);
    };

    const thumb = document.createElement('div'); 
    thumb.className='sticker-thumb';
    let contentName;

    if(isFlag){
      contentName = `Flag: ${s.flagId}`;
      thumb.textContent = 'ğŸ³ï¸â€âš§ï¸'; // Placeholder
    }
    else if(s.type==='emoji'){ 
      contentName = `Emoji: ${s.emoji}`;
      thumb.textContent=s.emoji; 
      thumb.style.fontSize = Math.min(40, s.h)+'px'; 
    }
    else { 
      contentName = 'Image Sticker';
      const img = document.createElement('img'); 
      img.src = s.img.src; 
      img.style.maxWidth='100%'; 
      img.style.maxHeight='100%'; 
      thumb.appendChild(img); 
    }

    const label = document.createElement('div'); 
    label.style.flex='1'; 
    label.innerHTML=`#${s.id} ${contentName} <br><small class="muted">${Math.round(s.x)},${Math.round(s.y)} (${Math.round(s.w)}x${Math.round(s.h)})</small>`;
    
    const btns = document.createElement('div'); 
    btns.style.display='flex'; 
    btns.style.gap='6px';
    
    const del = document.createElement('button'); 
    del.textContent='åˆ é™¤'; 
    del.style.background='#ef4444'; 
    del.onclick=()=>{ 
      if(isFlag){
        flagObject = null;
        state.selectedFlagId = 'none';
        document.querySelectorAll('.flag-item').forEach(el=>el.classList.remove('active'));
        document.querySelector('.flag-item[data-id="none"]').classList.add('active');
        state.selectedObjectId = null;
      } else {
        objects = objects.filter(x=>x.id!==s.id); 
        if(state.selectedObjectId === s.id) state.selectedObjectId = null;
      }
      render(); 
      refreshStickerList(); 
    };

    const lock = document.createElement('button'); 
    lock.textContent = s.locked? 'è§£é”' : 'é”å®š'; 
    lock.style.background='#64748b'; 
    lock.onclick=()=>{ s.locked = !s.locked; refreshStickerList(); };
    
    btns.appendChild(del); 
    btns.appendChild(lock);
    
    e.appendChild(thumb); 
    e.appendChild(label); 
    e.appendChild(btns);
    stickerListEl.appendChild(e);
  });
}

// --- åŠŸèƒ½å®ç° ---
function selectFlag(id){ 
  state.selectedFlagId=id; 
  if(id==='none'){
    flagObject = null;
    state.selectedObjectId = null;
  } else {
    addFlagObject(id, null);
  }
  render(); 
}

function addFlagObject(flagId, img){ 
  const isCustom = flagId === 'custom';
  let w = 400, h = 400, rot = Math.PI/4; // Default for corner ribbon
  
  if(isCustom && img) { 
    w = canvas.width; h = canvas.height; rot = 0;
  } else if (flagId === 'full-cover') {
    w = canvas.width; h = canvas.height; rot = 0;
  }

  flagObject = { 
    id: 0, 
    type: 'flag', 
    flagId, 
    img, 
    x: 0, 
    y: 0, 
    w, 
    h, 
    opacity: 0.6, 
    rotation: rot, 
    locked: false 
  };
  state.selectedObjectId = 0;
  positionObjectByPreset(flagObject);
  refreshStickerList();
}

function addEmojiSticker(emoji){ 
  const s = { 
    id: nextObjectId++, 
    type:'emoji', 
    emoji, 
    x:0, 
    y:0, 
    w:40, 
    h:40, 
    opacity:1, 
    rotation:0, 
    locked:false 
  }; 
  objects.push(s); 
  state.selectedObjectId = s.id;
  positionObjectByPreset(s); 
  refreshStickerList(); 
  render(); 
}

function addImageSticker(img){ 
  const s = { 
    id: nextObjectId++, 
    type:'image', 
    img, 
    x:0, 
    y:0, 
    w:40, 
    h:40, 
    opacity:1, 
    rotation:0, 
    locked:false 
  }; 
  objects.push(s); 
  state.selectedObjectId = s.id;
  positionObjectByPreset(s); 
  refreshStickerList(); 
  render(); 
}

function getSelectedObject(){
  if(state.selectedObjectId === 0) return flagObject;
  return objects.find(o => o.id === state.selectedObjectId);
}

function positionObjectByPreset(obj){ 
  const [x,y,w,h,rot] = getPresetParams(state.presetPosition, obj); 
  obj.x=x; obj.y=y; obj.w=w; obj.h=h; obj.rotation = rot;
}

function applyPresetPosition(){ 
  const obj = getSelectedObject();
  if(!obj || obj.locked) return;
  positionObjectByPreset(obj);
  refreshStickerList();
}

function applySizeToSelected(w){ 
  const obj = getSelectedObject();
  if(!obj || obj.locked) return;
  obj.w = w;
  obj.h = w; // Keep aspect ratio for simple size control
  refreshStickerList(); 
}

function applyOpacityToSelected(op){ 
  const obj = getSelectedObject();
  if(!obj || obj.locked) return;
  obj.opacity = op; 
  refreshStickerList(); 
}

// Returns [x, y, w, h, rotation] based on preset position
function getPresetParams(pos, obj){ 
  const margin = 12; 
  const W = canvas.width, H = canvas.height; 
  let w = obj.w, h = obj.h;
  let rotation = obj.rotation || 0;

  if(obj.type !== 'flag'){ // Only for non-flag objects (stickers)
    w = 40; h = 40; rotation = 0;
    const size = w;
    switch(pos){
      case 'bottom-right': return [W - size - margin, H - size - margin, size, size, 0];
      case 'bottom-left': return [margin, H - size - margin, size, size, 0];
      case 'top-right': return [W - size - margin, margin, size, size, 0];
      case 'top-left': return [margin, margin, size, size, 0];
      case 'bottom': return [Math.round(W/2 - size/2), H - size - margin, size, size, 0];
      case 'top': return [Math.round(W/2 - size/2), margin, size, size, 0];
      default: return [obj.x, obj.y, obj.w, obj.h, obj.rotation]; // Keep current for 'none'
    }
  } 
  
  // Flag specific presets
  if(pos === 'full-cover'){
    return [0, 0, W, H, 0];
  }
  
  // *** ä¿®å¤ corner-ribbon ä½ç½®é€»è¾‘ ***
  if(pos === 'corner-ribbon'){
    w = 450; 
    h = 450; 
    rotation = Math.PI / 4; // 45 degrees
    
    // å…³é”®ç‚¹ï¼šå°†æ—‹è½¬ä¸­å¿ƒæ”¾åœ¨ç”»å¸ƒçš„å³ä¸‹è§’ï¼Œç„¶åå®šä½ x, y
    // å³ä¸‹è§’ (W, H)
    // æ—‹è½¬åçš„ç‰©ä½“åŸç‚¹ (x, y) åº”è¯¥åœ¨ (-w*sqrt(2)/2, -h*sqrt(2)/2) å¤„
    // ç»è¿‡å¤šæ¬¡å°è¯•ï¼Œå‘ç°å°†ç‰©ä½“æ”¾ç½®åœ¨ W-300, H-300 å¤„ï¼Œå¯ä»¥ä½¿å…¶æ—‹è½¬åå³ä¸‹è§’ä¸ç”»å¸ƒå³ä¸‹è§’å¯¹é½
    const size = W * 0.6; // 60% of canvas size for the bounding box
    w = size;
    h = size;
    // å°†å¯¹è±¡åŸç‚¹æ”¾åœ¨ (W - size/2) å’Œ (H - size/2) é™„è¿‘ï¼Œç„¶åæ—‹è½¬ã€‚
    // ä¸ºäº†ä½¿æ—‹è½¬åçš„å³ä¸‹è§’è´´åˆï¼Œéœ€è¦æ›´ç²¾ç¡®çš„åç§»ã€‚
    // ç»éªŒå€¼ï¼šä½¿ç”¨ W=H=512, w=h=450ï¼ŒåŸç‚¹åº”ä¸º (512 - 380, 512 - 130) å·¦å³
    const origin_x = W - 380;
    const origin_y = H - 130;
    return [origin_x, origin_y, w, h, rotation];
  }

  // Other presets for flag
  w = 120; h = 120; rotation = 0;
  switch(pos){
    case 'bottom-right': return [W - w - margin, H - h - margin, w, h, 0];
    case 'bottom-left': return [margin, H - h - margin, w, h, 0];
    case 'top-right': return [W - w - margin, margin, w, h, 0];
    case 'top-left': return [margin, margin, w, h, 0];
    case 'bottom': return [Math.round(W/2 - w/2), H - h - margin, w, h, 0];
    case 'top': return [Math.round(W/2 - w/2), margin, w, h, 0];
    default: return [obj.x, obj.y, obj.w, obj.h, obj.rotation];
  }
}

function resetAll(){ 
  avatarImg=null; 
  flagObject = null;
  state.selectedFlagId = 'none'; 
  objects=[]; 
  nextObjectId=1; 
  state.selectedObjectId = null;
  document.querySelectorAll('.flag-item').forEach(el=>el.classList.remove('active')); 
  document.querySelector('.flag-item').classList.add('active'); 
  render(); 
  refreshStickerList(); 
}

// draw flag generator returns an offscreen canvas
function generateFlagCanvas(id, w, h){ 
  const c = document.createElement('canvas'); 
  c.width=w; 
  c.height=h; 
  const g = c.getContext('2d');
  
  // Drawing logic for flags remains the same
  if(id==='trans'){
    const colors=['#5BCEFA','#F5A9B8','#FFFFFF','#F5A9B8','#5BCEFA'];
    const stripe = Math.ceil(h/5);
    colors.forEach((col,i)=>{ g.fillStyle=col; g.fillRect(0,i*stripe,w,stripe); });
  } else if(id==='lesbian'){
    const colors=['#D62E00','#FF8AA1','#FFFFFF','#C77C6A','#8A3B12'];
    const stripe = Math.ceil(h/5);
    colors.forEach((col,i)=>{ g.fillStyle=colors[i] || '#c76'; g.fillRect(0,i*stripe,w,stripe); });
  } else if(id==='bi'){
    const colors=['#D60270','#9B4F96','#0038A8'];
    g.fillStyle=colors[0]; g.fillRect(0,0,w, Math.round(h*0.45));
    g.fillStyle=colors[2]; g.fillRect(0,Math.round(h*0.55),w, Math.round(h*0.45));
    g.fillStyle=colors[1]; g.fillRect(0,Math.round(h*0.45),w, Math.round(h*0.1));
  } else if(id==='nonbinary'){
    const colors=['#FFF430','#FFFFFF','#9C59D1','#000000'];
    const stripe=Math.ceil(h/4);
    colors.forEach((col,i)=> { g.fillStyle=col; g.fillRect(0,i*stripe,w,stripe); });
  } else {
    g.clearRect(0,0,w,h);
  }
  return c;
}

// render main
function render(){
  // clear
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // draw background placeholder
  ctx.fillStyle='#ffffff'; ctx.fillRect(0,0,canvas.width,canvas.height);
  
  // draw avatar (cover-fit)
  if(avatarImg){
    const [sx,sy,sw,sh] = coverRect(avatarImg.width, avatarImg.height, canvas.width, canvas.height);
    // Draw in a square (for normal use cases)
    ctx.drawImage(avatarImg, sx, sy, sw, sh, 0, 0, canvas.width, canvas.height);
  } else {
    // *** ä¿®å¤å ä½å¤´åƒï¼šæ–¹å½¢èƒŒæ™¯ + åœ†å½¢å±…ä¸­äººåƒ ***
    
    // 1. æ–¹å½¢èƒŒæ™¯ï¼ˆç”¨äºæ¨¡æ‹Ÿæ–¹å¤´åƒ/æ™®é€šå›¾ç‰‡ï¼‰
    ctx.fillStyle='#e6eef8'; ctx.fillRect(0,0,canvas.width,canvas.height);
    
    // 2. åœ†å½¢å¤´åƒï¼ˆç”¨äºæ¨¡æ‹Ÿåœ†å¤´åƒï¼‰
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;
    const radius = 90;
    
    // ç»˜åˆ¶åœ†
    ctx.fillStyle='#cfe0ff'; 
    ctx.beginPath(); 
    ctx.arc(cx, cy - 40, radius, 0, Math.PI*2); 
    ctx.fill();
    
    // ç»˜åˆ¶è‚©è†€/èº«ä½“
    ctx.fillStyle='#cbd5e1'; 
    ctx.fillRect(cx - 100, H - 140, 200, 120);
    ctx.beginPath();
    ctx.arc(cx, cy - 40, radius, 0, Math.PI * 2); 
    ctx.clip(); // è£å‰ªï¼Œä»¥ä¾¿åœ¨åœ†å†…ç”»å›¾ï¼Œä½†è¿™é‡Œæˆ‘ä»¬ä¸éœ€è¦ã€‚
    
    // ä¿æŒåŸæ¥çš„æ–¹å—å ä½é€»è¾‘ä»¥ä¾¿ä½œä¸ºåŸºç¡€ï¼ˆä½†æˆ‘ä»¬ç”¨ä¸Šé¢æ›´ç²¾ç»†çš„åœ†å’ŒèƒŒæ™¯ä»£æ›¿äº†ï¼‰
  }

  const allObjects = (flagObject ? [flagObject] : []).concat(objects);

  // draw all objects (flags and stickers)
  for(const s of allObjects){ 
    ctx.save(); 
    ctx.globalAlpha = s.opacity ?? 1;
    
    // Set up transform for movement, scaling, and rotation
    ctx.translate(s.x + s.w/2, s.y + s.h/2);
    ctx.rotate(s.rotation);
    ctx.translate(-(s.x + s.w/2), -(s.y + s.h/2));

    // Draw the object
    if(s.type==='emoji'){
      ctx.font = (s.h)+'px serif'; 
      ctx.textAlign='center'; 
      ctx.textBaseline='middle'; 
      ctx.fillText(s.emoji, s.x + s.w/2, s.y + s.h/2);
    } else if(s.type==='image' || s.type==='flag'){
      let imgToDraw = s.img;
      if(s.type==='flag' && !s.img){ 
        imgToDraw = generateFlagCanvas(s.flagId, s.w, s.h);
        ctx.drawImage(imgToDraw, s.x, s.y, s.w, s.h);
      } else if (imgToDraw) { 
        ctx.drawImage(imgToDraw, s.x, s.y, s.w, s.h);
      }
    }
    
    // Draw selection box and handles if selected
    if(s.id === state.selectedObjectId) {
      ctx.restore(); // Restore context before drawing selection box to avoid issues with transform
      ctx.save();
      
      // Re-apply transform for selection box
      ctx.translate(s.x + s.w/2, s.y + s.h/2);
      ctx.rotate(s.rotation);
      ctx.translate(-(s.x + s.w/2), -(s.y + s.h/2));
      
      // Draw selection box
      ctx.strokeStyle = '#3b82f6';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.strokeRect(s.x, s.y, s.w, s.h);
      ctx.setLineDash([]);
      
      // Draw handles (for move, scale, rotate)
      ctx.fillStyle = '#3b82f6';
      const handleSize = 10;
      
      // Corner handles (for scaling/stretching)
      ctx.fillRect(s.x - handleSize/2, s.y - handleSize/2, handleSize, handleSize); // Top-left
      ctx.fillRect(s.x + s.w - handleSize/2, s.y - handleSize/2, handleSize, handleSize); // Top-right
      ctx.fillRect(s.x - handleSize/2, s.y + s.h - handleSize/2, handleSize, handleSize); // Bottom-left
      ctx.fillRect(s.x + s.w - handleSize/2, s.y + s.h - handleSize/2, handleSize, handleSize); // Bottom-right
      
      // Rotation handle (top center, extended)
      ctx.beginPath();
      ctx.moveTo(s.x + s.w/2, s.y - handleSize/2);
      ctx.lineTo(s.x + s.w/2, s.y - 30);
      ctx.strokeStyle = '#3b82f6';
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(s.x + s.w/2, s.y - 30, handleSize/2, 0, Math.PI*2);
      ctx.fill();

      ctx.restore();
    }
    
    ctx.restore();
  }
}

function coverRect(imgW, imgH, boxW, boxH){ 
  const r = Math.max(boxW/imgW, boxH/imgH); 
  const sw = Math.round(boxW / r); 
  const sh = Math.round(boxH / r); 
  const sx = Math.round((imgW - sw) / 2); 
  const sy = Math.round((imgH - sh) / 2); 
  return [sx,sy,sw,sh]; 
}

// download
function downloadPNG(){ 
  // Temporarily remove selection box before downloading
  const tempSelectedId = state.selectedObjectId;
  state.selectedObjectId = null;
  render(); // Re-render without selection box
  
  const data = canvas.toDataURL('image/png'); 
  const a = document.createElement('a'); 
  a.href=data; 
  a.download='avatar_with_flag.png'; 
  a.click(); 
  
  // Restore selection box
  state.selectedObjectId = tempSelectedId;
  render();
}

// --- drag & drop / interaction with scaling and rotation ---
let dragging = null; // The object being manipulated
let dragMode = null; // 'move', 'scale-tl', 'scale-tr', 'scale-bl', 'scale-br', 'rotate'
let dragStart = {x: 0, y: 0};
let initialProps = {};

function getCanvasPos(e){ 
  const rect = canvas.getBoundingClientRect(); 
  // Calculate position relative to canvas coordinates (512x512)
  return { 
    x: (e.clientX - rect.left) * (canvas.width/rect.width), 
    y: (e.clientY - rect.top) * (canvas.height/rect.height) 
  }; 
}

// Utility to rotate a point (x, y) around a center (cx, cy) by an angle (rad)
function rotatePoint(x, y, cx, cy, angle) {
  const dx = x - cx;
  const dy = y - cy;
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  const rx = dx * cos - dy * sin;
  const ry = dx * sin + dy * cos;
  return { x: rx + cx, y: ry + cy };
}

// Utility to check if a point is near a handle or inside an object
function getInteractionMode(p, s){
  if(s.locked) return null;
  const cx = s.x + s.w/2;
  const cy = s.y + s.h/2;
  const angle = s.rotation;
  const handleSize = 10;
  
  // Get transformed corner coordinates and center of rotation handle
  const corners = [
    rotatePoint(s.x, s.y, cx, cy, angle), // TL
    rotatePoint(s.x + s.w, s.y, cx, cy, angle), // TR
    rotatePoint(s.x, s.y + s.h, cx, cy, angle), // BL
    rotatePoint(s.x + s.w, s.y + s.h, cx, cy, angle) // BR
  ];
  const rotHandle = rotatePoint(s.x + s.w/2, s.y - 30, cx, cy, angle);

  // Check rotation handle
  const rotDistSq = (p.x - rotHandle.x)**2 + (p.y - rotHandle.y)**2;
  if(rotDistSq < (handleSize/2 + 5)**2) return 'rotate';

  // Check scale handles
  if((p.x - corners[0].x)**2 + (p.y - corners[0].y)**2 < (handleSize/2 + 5)**2) return 'scale-tl';
  if((p.x - corners[1].x)**2 + (p.y - corners[1].y)**2 < (handleSize/2 + 5)**2) return 'scale-tr';
  if((p.x - corners[2].x)**2 + (p.y - corners[2].y)**2 < (handleSize/2 + 5)**2) return 'scale-bl';
  if((p.x - corners[3].x)**2 + (p.y - corners[3].y)**2 < (handleSize/2 + 5)**2) return 'scale-br';

  // Check move (inside the object's bounds, transformed)
  // Inverse rotate the click point to check against unrotated bounds
  const p_inv = rotatePoint(p.x, p.y, cx, cy, -angle);
  if (p_inv.x >= s.x && p_inv.x <= s.x + s.w && p_inv.y >= s.y && p_inv.y <= s.y + s.h) {
    return 'move';
  }
  
  return null;
}

canvas.addEventListener('mousedown', e=>{
  const p = getCanvasPos(e);
  const allObjects = (flagObject ? [flagObject] : []).concat(objects);
  
  // Find topmost object under cursor
  for(let i=allObjects.length-1;i>=0;i--){ 
    const s=allObjects[i]; 
    state.selectedObjectId = s.id; // Select the object first
    
    dragMode = getInteractionMode(p, s);
    if(dragMode){
      if(s.locked){ dragMode = null; continue; }
      dragging = s; 
      dragStart = p;
      initialProps = { x: s.x, y: s.y, w: s.w, h: s.h, rotation: s.rotation };
      
      // If it's a sticker, bring it to top (Flag always stays ID 0)
      if(s.id !== 0){
        const index = objects.findIndex(o => o.id === s.id);
        if(index > -1){
          objects.splice(index, 1); 
          objects.push(s);
        }
      }
      refreshStickerList(); 
      render(); 
      return; 
    }
  }
  
  // If no object was hit, deselect
  state.selectedObjectId = null;
  refreshStickerList();
  render();
});

window.addEventListener('mousemove', e=>{ 
  if(!dragging) return; 
  const p = getCanvasPos(e);
  const dx = p.x - dragStart.x;
  const dy = p.y - dragStart.y;
  
  const s = dragging;
  const cx = initialProps.x + initialProps.w/2;
  const cy = initialProps.y + initialProps.h/2;
  
  if(dragMode === 'move'){
    s.x = initialProps.x + dx;
    s.y = initialProps.y + dy;
  } 
  else if(dragMode.startsWith('scale-')){
    // Get the current mouse position rotated back
    const p_rot_inv = rotatePoint(p.x, p.y, cx, cy, -initialProps.rotation);
    const start_rot_inv = rotatePoint(dragStart.x, dragStart.y, cx, cy, -initialProps.rotation);
    
    const dx_inv = p_rot_inv.x - start_rot_inv.x;
    const dy_inv = p_rot_inv.y - start_rot_inv.y;
    
    let newX = initialProps.x;
    let newY = initialProps.y;
    let newW = initialProps.w;
    let newH = initialProps.h;

    // Apply scale changes based on the corner being dragged
    if (dragMode.includes('tl') || dragMode.includes('bl')) {
      newX = initialProps.x + dx_inv;
      newW = initialProps.w - dx_inv;
    }
    if (dragMode.includes('tr') || dragMode.includes('br')) {
      newW = initialProps.w + dx_inv;
    }
    if (dragMode.includes('tl') || dragMode.includes('tr')) {
      newY = initialProps.y + dy_inv;
      newH = initialProps.h - dy_inv;
    }
    if (dragMode.includes('bl') || dragMode.includes('br')) {
      newH = initialProps.h + dy_inv;
    }
    
    // Safety check for min size
    const minSize = 10;
    if (newW > minSize) { s.w = newW; s.x = newX; }
    if (newH > minSize) { s.h = newH; s.y = newY; }

  }
  else if(dragMode === 'rotate'){
    const initialVector = { x: dragStart.x - cx, y: dragStart.y - cy };
    const currentVector = { x: p.x - cx, y: p.y - cy };
    
    const initialAngle = Math.atan2(initialVector.y, initialVector.x);
    const currentAngle = Math.atan2(currentVector.y, currentVector.x);
    
    s.rotation = initialProps.rotation + (currentAngle - initialAngle);
  }
  
  render(); 
  refreshStickerList();
});

window.addEventListener('mouseup', e=>{ 
  if(dragging) dragging=null; 
  dragMode = null;
});

// init default flag and render
addFlagObject('trans'); // Default to trans flag ribbon
render(); 
refreshStickerList();

</script>
</body>
</html>